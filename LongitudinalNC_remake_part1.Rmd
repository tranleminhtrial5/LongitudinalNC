---
title: "Longitudinal trajectories of segmental bioimpedance and cognitive conversion in older adults"
output: html_notebook
---

Longitudinal trajectories of segmental bioimpedance and cognitive conversion in older adults

------------------------------------------------------------------------

```{r}
# Data manipulation
library(dplyr)
library(tidyr)
library(tibble)
library(lubridate)
library(stringr)

# Visualization
library(ggplot2)
library(cowplot)
library(ggpubr)
library(patchwork)
library(sjPlot)

# Statistical analysis
library(lme4)
library(rstatix)
library(effectsize)
library(emmeans)
library(broom)
library(broom.mixed)

# Reporting
library(gtsummary)
library(flextable)
library(summarytools)
library(tableone)
library(effsize)
library(scales)
library(tidyverse)

```

```{r}
df <- read.csv("Chosun5yBIApreprocess.csv", stringsAsFactors = FALSE)

remove_list <- c("E_237", "F_242", "a_531", "E_391", "G_31", "F_385", "a_281")
df <- df %>% filter(!(k_no %in% remove_list))

df <- df %>%
  mutate(datetest = as.Date(datetest, format = "%m/%d/%Y"))

df2 <- df %>%
  group_by(USUBJID) %>%
  filter(n() >= 2) %>%
  ungroup()

df2 <- df2 %>%
  arrange(USUBJID, datetest)

df3 <- df2 %>%
  group_by(USUBJID) %>%
  mutate(
    Initial_Status = first(diagnosis),
    Final_Status = last(diagnosis),
    Transition     = paste(Initial_Status, "-", Final_Status),
    Change_Type    = case_when(
      Initial_Status == "CN"  & Final_Status == "CN"  ~ "StableCN",
      Initial_Status == "CN"  & Final_Status == "MCI" ~ "CNtransitMCI",
      Initial_Status == "MCI" & Final_Status == "CN"  ~ "MCItransitCN",
      Initial_Status == "MCI" & Final_Status == "MCI" ~ "StableMCI",
      Initial_Status == "MCI" & Final_Status == "AD"  ~ "MCItransitAD",
      Initial_Status == "CN"  & Final_Status == "AD"  ~ "CNtransitAD",
      Initial_Status == "AD"  & Final_Status == "MCI" ~ "ADtransitMCI",
      Initial_Status == "AD"  & Final_Status == "CN"  ~ "ADtransitCN",
      Initial_Status == "AD"  & Final_Status == "AD"  ~ "StableAD",
      TRUE ~ NA_character_
    ),
    visit_count = n(),
    baseline_date = first(datetest),
    elapsed_years = as.numeric(difftime(datetest, baseline_date, units = "days")) / 365.25,
    elapsed_years_First_to_Last = as.numeric(difftime(last(datetest), first(datetest), units = "days")) / 365.25
  ) %>%
  ungroup()

df4 <- df3 %>%
  filter(elapsed_years_First_to_Last >= 0.916666666)
#write.csv(df4, "df4.csv",row.names = FALSE)

group_counts <- df4 %>%
  group_by(Transition, Change_Type) %>%
  summarise(count = n()) %>%
  mutate(percentage = count / sum(count) * 100)

print(head(df4))
print(group_counts)

# Unique participant-level summary for each Transition and Change_Type group
participant_group_summary <- df4 %>%
  group_by(USUBJID) %>%
  summarise(
    Transition = first(Transition),
    Change_Type = first(Change_Type)
  ) %>%
  group_by(Transition, Change_Type) %>%
  summarise(
    n_participants = n(),
    participants = paste(USUBJID, collapse = ", ")
  ) %>%
  ungroup()

print(participant_group_summary)

```

```{r}
# ---- Libraries ----
library(dplyr)
library(tableone)
library(effsize)
library(emmeans)
library(tibble)
library(DescTools) # for Cramér's V and CI

output_dir <- "Baseline_Results"
if (!dir.exists(output_dir)) dir.create(output_dir)

### --- Data Preparation: get baseline per subject ---
df_baseline <- df4 %>%
  filter(Change_Type %in% c("StableCN", "CNtransitMCI")) %>%
  group_by(USUBJID) %>%
  filter(datetest == min(datetest)) %>%
  ungroup()

df_baseline$SEX <- as.factor(df_baseline$SEX)
df_baseline$Change_Type <- factor(df_baseline$Change_Type, levels = c("StableCN", "CNtransitMCI"))

group_var <- "Change_Type"

# ---- Table 1: Demographics & Cognition ----
vars_table1 <- c('SEX','AGE','EDUYR','gds','kdsq','visit_count','MMSE',
                 'SNSB_attention','SNSB_language','SNSB_visuospatial',
                 'SNSB_memory','SNSB_frontal')

tab1 <- CreateTableOne(vars = vars_table1, strata = group_var, data = df_baseline, test = FALSE)

get_missing_pct <- function(x, g) {
  res <- tapply(is.na(x), g, mean)
  res[is.na(res)] <- 0
  res * 100
}

table1stats <- lapply(vars_table1, function(v) {
  x <- df_baseline[[v]]
  g <- df_baseline[[group_var]]
  miss_pct <- get_missing_pct(x, g)
  if (length(unique(g)) != 2) return(data.frame(
    Variable = v, Type = NA, Pvalue = NA, SMD = NA, SMD_L = NA, SMD_U = NA, EffectSize = NA,
    Miss_StableCN = NA, Miss_CNtransitMCI = NA))
  
  if (is.factor(x) | is.character(x)) {
    tbl <- table(x, g)
    use_fisher <- any(tbl < 5)
    pval <- if (use_fisher) fisher.test(tbl)$p.value else chisq.test(tbl)$p.value
    # Cramér's V or Cohen's h for binary
    es <- tryCatch({
      if (nlevels(as.factor(x))==2) {
        counts <- table(x, g)
        p1 <- prop.table(counts,2)[1,1]
        p2 <- prop.table(counts,2)[1,2]
        2*abs(asin(sqrt(p1))-asin(sqrt(p2)))
      } else {
        DescTools::CramerV(tbl, ci = FALSE)
      }
    }, error=function(e) NA)
    return(data.frame(
      Variable = v, Type = "cat", Pvalue = pval, SMD = NA, SMD_L = NA, SMD_U = NA, EffectSize = round(es, 3),
      Miss_StableCN = round(miss_pct["StableCN"], 2), Miss_CNtransitMCI = round(miss_pct["CNtransitMCI"],2)
    ))
  }
  
  # For numeric variables, Cohen's d (with 95% CI)
  is_norm <- tryCatch((shapiro.test(na.omit(x))$p.value > 0.05), error=function(e) FALSE)
  test_result <- if (is_norm) t.test(x ~ g) else wilcox.test(x ~ g)
  cd <- effsize::cohen.d(x, g, hedges.correction = TRUE, conf.level = 0.95)
  return(data.frame(
    Variable = v, Type = "num", Pvalue = test_result$p.value, SMD = cd$estimate, SMD_L = cd$conf.int[1], SMD_U = cd$conf.int[2], EffectSize = cd$estimate,
    Miss_StableCN = round(miss_pct["StableCN"],2), Miss_CNtransitMCI = round(miss_pct["CNtransitMCI"],2)))
})
df_table1stats <- bind_rows(table1stats)

# Export Table 1
write.csv(print(tab1, quote = TRUE, noSpaces = TRUE), file.path(output_dir,"table1_baseline.csv"))
write.csv(df_table1stats, file.path(output_dir, "table1_baseline_stats_full.csv"), row.names = FALSE)
cat("Table 1 exported as .csv files in", output_dir, "\n")

# ---- Table 2: Anthropometry & Body Composition (Adjusted) ----
vars_table2 <- c('height','weight','Waistcir','Hipcir','bmi','ac','whr',
                 'pbcm','pbf','bmr','tbw_ffm','ecw_tcw','PA50_total')
covars <- c("AGE", "SEX", "EDUYR")
units_table2 <- c(height = "cm", weight = "kg", Waistcir = "cm", Hipcir = "cm", sysbp = "mmHg", diabp = "mmHg",
                  bmi = "kg/m2", ac = "", whr = "", pbcm = "%", pbf = "%", bmr = "kcal", tbw_ffm = "%", ecw_tcw = "%", PA50_total = "degree")

get_sample_size <- function(df, v, lvl) sum(!is.na(df[[v]]) & df[[group_var]] == lvl)
get_missing_pct_tbl <- function(df, v, lvl) mean(is.na(df[[v]]) & df[[group_var]] == lvl) * 100

get_ancova_table <- function(varlist, groupvar, covars, df, units = NULL) {
  lapply(varlist, function(v) {
    fml <- as.formula(paste(v, "~", groupvar, "+", paste(covars, collapse = " + ")))
    model <- lm(fml, data = df, na.action = na.exclude)
    emm <- emmeans(model, groupvar)
    summary_emm <- summary(emm, level = 0.95)
    contrasts <- summary(contrast(emm, method = "pairwise"), infer = TRUE)
    aovm <- tryCatch(anova(model), error = function(e) NULL)
    eta2 <- tryCatch({
      ss_group <- aovm[groupvar, "Sum Sq"]
      ss_total <- sum(aovm[,"Sum Sq"])
      ss_group/ss_total
    }, error = function(e) NA)
    adj_r2 <- tryCatch(summary(model)$adj.r.squared, error = function(e) NA)
    g1 <- levels(df[[group_var]])[1]
    g2 <- levels(df[[group_var]])[2]
    n1 <- get_sample_size(df, v, g1)
    n2 <- get_sample_size(df, v, g2)
    miss1 <- get_missing_pct_tbl(df, v, g1)
    miss2 <- get_missing_pct_tbl(df, v, g2)
    tibble(
      Variable = v,
      Unit = if (!is.null(units) && !is.na(units[v])) units[v] else "",
      N_StableCN = n1,
      N_CNtransitMCI = n2,
      StableCN_AdjMean_CI = sprintf("%.2f (%.2f, %.2f)", summary_emm$emmean[summary_emm[[groupvar]] == g1],
                                    summary_emm$lower.CL[summary_emm[[groupvar]] == g1],
                                    summary_emm$upper.CL[summary_emm[[groupvar]] == g1]),
      CNtransitMCI_AdjMean_CI = sprintf("%.2f (%.2f, %.2f)", summary_emm$emmean[summary_emm[[groupvar]] == g2],
                                        summary_emm$lower.CL[summary_emm[[groupvar]] == g2],
                                        summary_emm$upper.CL[summary_emm[[groupvar]] == g2]),
      Diff_CI = sprintf("%.2f (%.2f, %.2f)", contrasts$estimate[1], contrasts$lower.CL[1], contrasts$upper.CL[1]),
      SE = round(contrasts$SE[1],2),
      PValue = round(contrasts$p.value[1],4),
      EtaSq = round(eta2,3),
      Adj_R2 = round(adj_r2,3),
      Miss_StableCN = round(miss1,2),
      Miss_CNtransitMCI = round(miss2,2)
    )
  }) %>% bind_rows()
}

tbl2_journal <- get_ancova_table(vars_table2, group_var, covars, df_baseline, units_table2)
write.csv(tbl2_journal, file.path(output_dir, "table2_journalformat_full.csv"), row.names = FALSE)
cat("Table 2 exported as .csv file in", output_dir, "\n")

# ---- Table 3: Segmental Variables (Adjusted) ----
vars_table3 <- c('ECW_ICW_upper','ECW_ICW_lower','Water_Lean_upper','Water_Lean_lower',
                 'R_upper','R_lower','Xc_upper','Xc_lower','PA_upper','PA_lower',
                 'R_H_upper','R_H_lower','Xc_H_upper','Xc_H_lower')
units_table3 <- c(
  ECW_ICW_upper = "%", ECW_ICW_lower = "%", Water_Lean_upper = "%", Water_Lean_lower = "%",
  R_upper = "Ohm", R_lower = "Ohm", Xc_upper = "Ohm", Xc_lower = "Ohm",
  PA_upper = "degree", PA_lower = "degree", R_H_upper = "Ohm", R_H_lower = "Ohm",
  Xc_H_upper = "Ohm", Xc_H_lower = "Ohm"
)
tbl3_journal <- get_ancova_table(vars_table3, group_var, covars, df_baseline, units_table3)
write.csv(tbl3_journal, file.path(output_dir, "table3_journalformat_full.csv"), row.names = FALSE)
cat("Table 3 exported as .csv file in", output_dir, "\n")


```

```{r}
bia_vars <- c("MMSE","SNSB_attention","SNSB_language", "SNSB_visuospatial", "SNSB_memory", "SNSB_frontal","bmi","whr","pbcm","pbf","bmr","ecw_tcw","tbw_ffm","PA50_total",
              "ECW_ICW_upper","ECW_ICW_lower","Water_Lean_upper","Water_Lean_lower",
              "R_upper","R_lower","Xc_upper","Xc_lower",
              "PA_upper","PA_lower","R_H_upper","R_H_lower","Xc_H_upper","Xc_H_lower")

df_long.analysis <- df4 %>%
  filter(Change_Type %in% c("StableCN", "CNtransitMCI"))

spaghetti_plots <- lapply(bia_vars, function(var) {
  ggplot(df_long.analysis, aes(x = elapsed_years, y = .data[[var]], group = USUBJID, color = Change_Type)) +
    geom_line(alpha = 0.35) +
    geom_smooth(aes(group = Change_Type, color = Change_Type), method = "loess", se = FALSE, linewidth = 1.5) +
    labs(title = paste("Spaghetti Plot:", var), y = var, x = "Years") +
    theme_minimal()
})

do.call(cowplot::plot_grid, c(spaghetti_plots[1:6], ncol = 2))

do.call(cowplot::plot_grid, c(spaghetti_plots[1:9], ncol = 3))

print(spaghetti_plots[[1]])   

#for(i in seq_along(bia_vars)) {
#  ggsave(filename = paste0("spaghetti_", bia_vars[i], ".png"),
#         plot = spaghetti_plots[[i]], width = 6, height = 4)
#}
```
```{r}
# Trial
# --- Libraries ---
library(lmerTest)
library(emmeans)
library(dplyr)
library(tibble)
library(ggeffects)
library(forcats)
library(ggplot2)  # For plot annotation

# --- Group Colors ---
colors.legend <- c(
  "StableCN" = "#1f77b4",      # Blue (Stable/Control)
  "CNtransitMCI" = "#ff7f0e"   # Orange (Transition group)
)

# --- Data Prep ---
df_long.analysis$Change_Type <- as.factor(df_long.analysis$Change_Type)
df_long.analysis$Change_Type <- fct_recode(
  df_long.analysis$Change_Type,
  StableCN = "StableCN", 
  CNtransitMCI = "CNtransitMCI"
)
print(levels(df_long.analysis$Change_Type)) 
print(table(df_long.analysis$Change_Type, useNA = "always"))

referencegroup <- "StableCN"
comparisongroups <- c("CNtransitMCI")

# --- Core Analysis Function: LME + LRT + Wald ---
analyze_longitudinal_trends_LRT <- function(
  data, response, xvar = "elapsed_years", groupvar = "Change_Type",
  covariates = c("AGE", "SEX", "EDUYR"), subjectid = "USUBJID",
  referencegroup, comparisongroups
) {
  # Validate group levels first
  levels_grp <- levels(as.factor(data[[groupvar]]))
  if (!referencegroup %in% levels_grp) stop(paste("Reference group", referencegroup, "not found in levels"))
  if (any(!comparisongroups %in% levels_grp)) stop(paste("Comparison group(s)", paste(comparisongroups[!comparisongroups %in% levels_grp], collapse=", "), "not found in levels"))

  # Set reference level for modeling
  data[[groupvar]] <- as.factor(data[[groupvar]])
  data[[groupvar]] <- relevel(data[[groupvar]], ref = referencegroup)
  
  # Model formulas
  formula_full <- as.formula(
    paste0(response, " ~ ", xvar, "*", groupvar, " + ", paste(covariates, collapse = " + "), 
           " + (1 + ", xvar, "|", subjectid, ")")
  )
  formula_noint <- as.formula(
    paste0(response, " ~ ", xvar, " + ", groupvar, " + ", paste(covariates, collapse = " + "), 
           " + (1 + ", xvar, "|", subjectid, ")")
  )
  
  # Check for all NA or missing column
  if (!response %in% names(data) || all(is.na(data[[response]]))) {
    warning(paste("Skipping", response, "because data is missing or all NA"))
    return(list(modelsummary = tibble(Outcome = response, Comparison = paste(comparisongroups, "vs", referencegroup),
                                         Slope_Ref = NA, Slope_Comp = NA, Slope_Diff = NA,
                                         Slope_SE = NA, Slope_Lower = NA, Slope_Upper = NA,
                                         Slope_p = NA, Cohen_d = NA, Wald_p = NA,
                                         LRT_p = NA, LRT_chi = NA, LRT_df = NA, ResidualSD = NA)))
  }
  
  # Fit models
  mod_full <- tryCatch(lmerTest::lmer(formula_full, data = data, REML=FALSE), error = function(e) NA)
  mod_noint <- tryCatch(lmerTest::lmer(formula_noint, data = data, REML=FALSE), error = function(e) NA)
  if (any(is.na(c(mod_full, mod_noint)))) {
    warning(paste("Model fit failed for", response))
    return(list(modelsummary = tibble(Outcome = response, Comparison = paste(comparisongroups, "vs", referencegroup),
                                         Slope_Ref = NA, Slope_Comp = NA, Slope_Diff = NA,
                                         Slope_SE = NA, Slope_Lower = NA, Slope_Upper = NA,
                                         Slope_p = NA, Cohen_d = NA, Wald_p = NA,
                                         LRT_p = NA, LRT_chi = NA, LRT_df = NA, ResidualSD = NA)))
  }
  
  # LRT p-value
  lrt <- anova(mod_noint, mod_full)
  lrt_p <- lrt$`Pr(>Chisq)`[2]
  lrt_chi <- lrt$Chisq[2]
  lrt_df <- lrt$Df[2]
  
  # Wald p-value
  coefmat <- coef(summary(mod_full))
  interaction_row <- grep(paste0(xvar, ":", groupvar), rownames(coefmat), value = TRUE)
  wald_p <- if(length(interaction_row) > 0) coefmat[interaction_row, "Pr(>|t|)"] else NA_real_
  
  # Slope extraction
  emt <- emmeans::emtrends(mod_full, specs = groupvar, var = xvar)
  sum_emt <- summary(emt, infer = TRUE)
  slope_tests <- sum_emt %>% dplyr::rename(slope = !!paste0(xvar, ".trend"), group = !!groupvar)
  refstats <- slope_tests %>% filter(group == referencegroup)
  compstats <- lapply(comparisongroups, function(g) slope_tests %>% filter(group == g))
  names(compstats) <- comparisongroups
  
  # Slope difference & 95% CI
  contrast_out <- emmeans::contrast(emt, method = "revpairwise")
  sum_contrast <- summary(contrast_out, infer = TRUE)

  # Effect size
  sigma_resid <- suppressWarnings(sigma(mod_full))
  cohensd <- sapply(comparisongroups, function(g) {
    comp <- compstats[[g]]$slope
    ref <- refstats$slope
    if (length(comp)==0 || length(ref)==0 || is.na(sigma_resid)) {
      NA
    } else {
      abs((comp - ref)/sigma_resid)
    }
  })
  
  # Output summary: robust to missing pairwise
  meta_rows <- lapply(comparisongroups, function(g) {
  contrastA <- paste(referencegroup, g, sep = " - ")
  contrastB <- paste(g, referencegroup, sep = " - ")
  idx <- which(sum_contrast$contrast %in% c(contrastA, contrastB))
  if(length(idx)==1 && nrow(refstats)==1 && nrow(compstats[[g]])==1) {
    # If the contrast is "g - referencegroup", flip sign
    sign_mult <- if (sum_contrast$contrast[idx] == contrastA) 1 else -1
    tibble(
      Outcome = response,
      Comparison = paste(g, "vs", referencegroup),
      Slope_Ref = round(refstats$slope, 4),
      Slope_Comp = round(compstats[[g]]$slope, 4),
      Slope_Diff = round(sign_mult * sum_contrast$estimate[idx], 4),
      Slope_SE = round(sum_contrast$SE[idx], 4),
      Slope_Lower = round(sign_mult * sum_contrast$lower.CL[idx], 4),
      Slope_Upper = round(sign_mult * sum_contrast$upper.CL[idx], 4),
      Slope_p = round(sum_contrast$p.value[idx], 5),
      Cohen_d = round(cohensd[g], 4),
      Wald_p = round(wald_p, 5),
      LRT_p = round(lrt_p, 5),
      LRT_chi = round(lrt_chi, 3),
      LRT_df = lrt_df,
      ResidualSD = round(sigma_resid, 3)
    )
  } else {
    tibble(
      Outcome = response,
      Comparison = paste(g, "vs", referencegroup),
      Slope_Ref = NA, Slope_Comp = NA, Slope_Diff = NA,
      Slope_SE = NA, Slope_Lower = NA, Slope_Upper = NA,
      Slope_p = NA, Cohen_d = NA, Wald_p = NA,
      LRT_p = NA, LRT_chi = NA, LRT_df = NA, ResidualSD = NA
    )
  }
})
  
  modelsummary <- bind_rows(meta_rows)
  list(
    modelsummary = modelsummary,
    mod_full = mod_full,
    mod_noint = mod_noint,
    lrt = lrt,
    wald_p = wald_p,
    slopes = sum_emt,
    contrast = sum_contrast,
    cohensd = cohensd
  )
}

# --- List of Markers ---
biavars <- c(
  "MMSE", "SNSB_attention", "SNSB_language", "SNSB_visuospatial", "SNSB_memory", "SNSB_frontal",
  "bmi", "whr", "pbcm", "pbf", "bmr", "ecw_tcw", "tbw_ffm", "PA50_total",
  "ECW_ICW_upper", "ECW_ICW_lower", "Water_Lean_upper", "Water_Lean_lower",
  "R_upper", "R_lower", "Xc_upper", "Xc_lower", "PA_upper", "PA_lower",
  "R_H_upper", "R_H_lower", "Xc_H_upper", "Xc_H_lower"
)

# --- Batch Analysis ---
results <- lapply(biavars, function(var) {
  print(paste("Analyzing:", var))
  analyze_longitudinal_trends_LRT(
    data = df_long.analysis,
    response = var,
    groupvar = "Change_Type",
    referencegroup = referencegroup,
    comparisongroups = comparisongroups
  )
})
modelsummarylist <- lapply(results, function(x) x$modelsummary)
allsummaries <- bind_rows(modelsummarylist, .id = "Biomarker")
write.csv(allsummaries, "Bioimpedance_LME_LRT_summary.csv", row.names = FALSE)

print("Check complete: Output summary table written!")

# --- Batch Plot Generation (Wald + LRT) ---
output_dir_wald <- "Bioimpedance_Trajectory_WaldPlots"
output_dir_lrt <- "Bioimpedance_Trajectory_LRTPlots"
dir.create(output_dir_wald, showWarnings = FALSE)
dir.create(output_dir_lrt, showWarnings = FALSE)
plots_wald <- lapply(biavars, function(var)
  plot_lmer_model_with_interaction_p(
    data = df_long.analysis,
    response = var,
    colors = colors.legend
  )
)
plots_lrt <- lapply(biavars, function(var)
  plot_lmer_interaction_with_p(
    data = df_long.analysis,
    response = var,
    colors = colors.legend,
    show.legend = TRUE  # Change this to TRUE to show group legend
  )
)
for (i in seq_along(biavars)) {
  pw <- plots_wald[[i]]
  pl <- plots_lrt[[i]]
  if (inherits(pw, "ggplot")) {
    ggsave(
      filename = file.path(output_dir_wald, paste0(biavars[i], "_waldplot.png")),
      plot = pw, width = 7, height = 5, dpi = 300
    )
  }
  if (inherits(pl, "ggplot")) {
    ggsave(
      filename = file.path(output_dir_lrt, paste0(biavars[i], "_lrtplot.png")),
      plot = pl, width = 7, height = 5, dpi = 300
    )
  }
}

# --- The Key Plot Function (only this part is new/changed!) ---
plot_lmer_interaction_with_p <- function(data, response, colors, show.legend = TRUE) {
  ggplot(data, aes(
      x = elapsed_years,
      y = .data[[response]],
      color = Change_Type,
      group = Change_Type
  )) +
    stat_summary(fun = mean, geom = "line", size = 1.1) +
    scale_color_manual(values = colors) +
    labs(
      title = paste(response, "trajectory by group"),
      color = "Group",
      x = "elapsed_years",
      y = response
    ) +
    theme_classic(base_size = 14) +
    theme(
      legend.position = if(show.legend) "top" else "none",
      legend.title = element_text(size = 13),
      legend.text = element_text(size = 12),
      plot.title = element_text(hjust = 0.5)
    )
}


```

```{r}
# --- Libraries ---
library(lmerTest)
library(emmeans)
library(dplyr)
library(tibble)
library(ggeffects)
library(forcats)

df_long.analysis$Change_Type <- as.factor(df_long.analysis$Change_Type)
df_long.analysis$Change_Type <- fct_recode(
  df_long.analysis$Change_Type,
  StableCN = "StableCN", 
  CNtransitMCI = "CNtransitMCI"
)
print(levels(df_long.analysis$Change_Type)) 
print(table(df_long.analysis$Change_Type, useNA = "always"))

referencegroup <- "StableCN"
comparisongroups <- c("CNtransitMCI")

# --- Core Analysis Function: LME + LRT + Wald ---
analyze_longitudinal_trends_LRT <- function(
  data, response, xvar = "elapsed_years", groupvar = "Change_Type",
  covariates = c("AGE", "SEX", "EDUYR"), subjectid = "USUBJID",
  referencegroup, comparisongroups
) {
  # Validate group levels first
  levels_grp <- levels(as.factor(data[[groupvar]]))
  if (!referencegroup %in% levels_grp) stop(paste("Reference group", referencegroup, "not found in levels"))
  if (any(!comparisongroups %in% levels_grp)) stop(paste("Comparison group(s)", paste(comparisongroups[!comparisongroups %in% levels_grp], collapse=", "), "not found in levels"))

  # Set reference level for modeling
  data[[groupvar]] <- as.factor(data[[groupvar]])
  data[[groupvar]] <- relevel(data[[groupvar]], ref = referencegroup)
  
  # Model formulas
  formula_full <- as.formula(
    paste0(response, " ~ ", xvar, "*", groupvar, " + ", paste(covariates, collapse = " + "), 
           " + (1 + ", xvar, "|", subjectid, ")")
  )
  formula_noint <- as.formula(
    paste0(response, " ~ ", xvar, " + ", groupvar, " + ", paste(covariates, collapse = " + "), 
           " + (1 + ", xvar, "|", subjectid, ")")
  )
  
  # Check for all NA or missing column
  if (!response %in% names(data) || all(is.na(data[[response]]))) {
    warning(paste("Skipping", response, "because data is missing or all NA"))
    return(list(modelsummary = tibble(Outcome = response, Comparison = paste(comparisongroups, "vs", referencegroup),
                                         Slope_Ref = NA, Slope_Comp = NA, Slope_Diff = NA,
                                         Slope_SE = NA, Slope_Lower = NA, Slope_Upper = NA,
                                         Slope_p = NA, Cohen_d = NA, Wald_p = NA,
                                         LRT_p = NA, LRT_chi = NA, LRT_df = NA, ResidualSD = NA)))
  }
  
  # Fit models
  mod_full <- tryCatch(lmerTest::lmer(formula_full, data = data, REML=FALSE), error = function(e) NA)
  mod_noint <- tryCatch(lmerTest::lmer(formula_noint, data = data, REML=FALSE), error = function(e) NA)
  if (any(is.na(c(mod_full, mod_noint)))) {
    warning(paste("Model fit failed for", response))
    return(list(modelsummary = tibble(Outcome = response, Comparison = paste(comparisongroups, "vs", referencegroup),
                                         Slope_Ref = NA, Slope_Comp = NA, Slope_Diff = NA,
                                         Slope_SE = NA, Slope_Lower = NA, Slope_Upper = NA,
                                         Slope_p = NA, Cohen_d = NA, Wald_p = NA,
                                         LRT_p = NA, LRT_chi = NA, LRT_df = NA, ResidualSD = NA)))
  }
  
  # LRT p-value
  lrt <- anova(mod_noint, mod_full)
  lrt_p <- lrt$`Pr(>Chisq)`[2]
  lrt_chi <- lrt$Chisq[2]
  lrt_df <- lrt$Df[2]
  
  # Wald p-value
  coefmat <- coef(summary(mod_full))
  interaction_row <- grep(paste0(xvar, ":", groupvar), rownames(coefmat), value = TRUE)
  wald_p <- if(length(interaction_row) > 0) coefmat[interaction_row, "Pr(>|t|)"] else NA_real_
  
  # Slope extraction
  emt <- emmeans::emtrends(mod_full, specs = groupvar, var = xvar)
  sum_emt <- summary(emt, infer = TRUE)
  slope_tests <- sum_emt %>% dplyr::rename(slope = !!paste0(xvar, ".trend"), group = !!groupvar)
  refstats <- slope_tests %>% filter(group == referencegroup)
  compstats <- lapply(comparisongroups, function(g) slope_tests %>% filter(group == g))
  names(compstats) <- comparisongroups
  
  # Slope difference & 95% CI
  contrast_out <- emmeans::contrast(emt, method = "revpairwise")
  sum_contrast <- summary(contrast_out, infer = TRUE)

  # Effect size
  sigma_resid <- suppressWarnings(sigma(mod_full))
  cohensd <- sapply(comparisongroups, function(g) {
    comp <- compstats[[g]]$slope
    ref <- refstats$slope
    if (length(comp)==0 || length(ref)==0 || is.na(sigma_resid)) {
      NA
    } else {
      abs((comp - ref)/sigma_resid)
    }
  })
  
  # Output summary: robust to missing pairwise
  meta_rows <- lapply(comparisongroups, function(g) {
  contrastA <- paste(referencegroup, g, sep = " - ")
  contrastB <- paste(g, referencegroup, sep = " - ")
  idx <- which(sum_contrast$contrast %in% c(contrastA, contrastB))
  if(length(idx)==1 && nrow(refstats)==1 && nrow(compstats[[g]])==1) {
    # If the contrast is "g - referencegroup", flip sign
    sign_mult <- if (sum_contrast$contrast[idx] == contrastA) 1 else -1
    tibble(
      Outcome = response,
      Comparison = paste(g, "vs", referencegroup),
      Slope_Ref = round(refstats$slope, 4),
      Slope_Comp = round(compstats[[g]]$slope, 4),
      Slope_Diff = round(sign_mult * sum_contrast$estimate[idx], 4),
      Slope_SE = round(sum_contrast$SE[idx], 4),
      Slope_Lower = round(sign_mult * sum_contrast$lower.CL[idx], 4),
      Slope_Upper = round(sign_mult * sum_contrast$upper.CL[idx], 4),
      Slope_p = round(sum_contrast$p.value[idx], 5),
      Cohen_d = round(cohensd[g], 4),
      Wald_p = round(wald_p, 5),
      LRT_p = round(lrt_p, 5),
      LRT_chi = round(lrt_chi, 3),
      LRT_df = lrt_df,
      ResidualSD = round(sigma_resid, 3)
    )
  } else {
    tibble(
      Outcome = response,
      Comparison = paste(g, "vs", referencegroup),
      Slope_Ref = NA, Slope_Comp = NA, Slope_Diff = NA,
      Slope_SE = NA, Slope_Lower = NA, Slope_Upper = NA,
      Slope_p = NA, Cohen_d = NA, Wald_p = NA,
      LRT_p = NA, LRT_chi = NA, LRT_df = NA, ResidualSD = NA
    )
  }
})

  
  modelsummary <- bind_rows(meta_rows)
  list(
    modelsummary = modelsummary,
    mod_full = mod_full,
    mod_noint = mod_noint,
    lrt = lrt,
    wald_p = wald_p,
    slopes = sum_emt,
    contrast = sum_contrast,
    cohensd = cohensd
  )
}

# --- List of Markers ---
biavars <- c(
  "MMSE", "SNSB_attention", "SNSB_language", "SNSB_visuospatial", "SNSB_memory", "SNSB_frontal",
  "bmi", "whr", "pbcm", "pbf", "bmr", "ecw_tcw", "tbw_ffm", "PA50_total",
  "ECW_ICW_upper", "ECW_ICW_lower", "Water_Lean_upper", "Water_Lean_lower",
  "R_upper", "R_lower", "Xc_upper", "Xc_lower", "PA_upper", "PA_lower",
  "R_H_upper", "R_H_lower", "Xc_H_upper", "Xc_H_lower"
)

# --- Batch Analysis ---
results <- lapply(biavars, function(var) {
  print(paste("Analyzing:", var))
  analyze_longitudinal_trends_LRT(
    data = df_long.analysis,
    response = var,
    groupvar = "Change_Type",
    referencegroup = referencegroup,
    comparisongroups = comparisongroups
  )
})
modelsummarylist <- lapply(results, function(x) x$modelsummary)
allsummaries <- bind_rows(modelsummarylist, .id = "Biomarker")
write.csv(allsummaries, "Bioimpedance_LME_LRT_summary.csv", row.names = FALSE)

print("Check complete: Output summary table written!")


# --- Batch Plot Generation (Wald + LRT) ---
output_dir_wald <- "Bioimpedance_Trajectory_WaldPlots"
output_dir_lrt <- "Bioimpedance_Trajectory_LRTPlots"
dir.create(output_dir_wald, showWarnings = FALSE)
dir.create(output_dir_lrt, showWarnings = FALSE)
plots_wald <- lapply(biavars, function(var)
  plot_lmer_model_with_interaction_p(
    data = df_long.analysis,
    response = var,
    colors = colors.legend
  )
)
plots_lrt <- lapply(biavars, function(var)
  plot_lmer_interaction_with_p(
    data = df_long.analysis,
    response = var,
    colors = colors.legend,
    show.legend = FALSE
  )
)
for (i in seq_along(biavars)) {
  pw <- plots_wald[[i]]
  pl <- plots_lrt[[i]]
  if (inherits(pw, "ggplot")) {
    ggsave(
      filename = file.path(output_dir_wald, paste0(biavars[i], "_waldplot.png")),
      plot = pw, width = 7, height = 5, dpi = 300
    )
  }
  if (inherits(pl, "ggplot")) {
    ggsave(
      filename = file.path(output_dir_lrt, paste0(biavars[i], "_lrtplot.png")),
      plot = pl, width = 7, height = 5, dpi = 300
    )
  }
}

```

```{r}
library(performance)

if (!dir.exists("Diagnostics")) dir.create("Diagnostics")

safe_var_extract <- function(vardf, grpval, var1val, var2val) {
  idx <- which(vardf$grp==grpval & vardf$var1==var1val & vardf$var2==var2val)
  if(length(idx)==1 && !is.na(vardf$vcov[idx])) vardf$vcov[idx] else NA_real_
}

safe_r2 <- function(model) {
  out <- tryCatch(
    suppressWarnings(performance::r2(model)),
    error = function(e) list(R2_marginal=NA_real_, R2_conditional=NA_real_)
  )
  list(marginal=out$R2_marginal, conditional=out$R2_conditional)
}

diagnostics_list <- lapply(seq_along(biavars), function(i) {
  var <- biavars[i]
  m <- results[[i]]$mod_full

  png(filename = sprintf("Diagnostics/%s_QQplot.png", var), width = 700, height = 700)
  qqnorm(residuals(m)); qqline(residuals(m)); dev.off()

  png(filename = sprintf("Diagnostics/%s_ResVsFitted.png", var), width = 700, height = 700)
  plot(fitted(m), residuals(m), main = paste(var, "Fitted vs Residuals"),
       xlab = "Fitted Values", ylab = "Residuals"); abline(h = 0, lty = 2); dev.off()

  aic <- tryCatch(AIC(m), error=function(e) NA_real_)
  bic <- tryCatch(BIC(m), error=function(e) NA_real_)
  r2 <- safe_r2(m)
  ranef_var <- tryCatch(as.data.frame(VarCorr(m)), error=function(e) data.frame())
  rand_intercept <- if(nrow(ranef_var)>0) safe_var_extract(ranef_var,"USUBJID","","") else NA_real_
  rand_slope <- if(nrow(ranef_var)>0) safe_var_extract(ranef_var,"USUBJID","elapsed_years","") else NA_real_
  conv_warn <- if (!is.null(m@optinfo$conv$lme4$messages)) paste(m@optinfo$conv$lme4$messages, collapse="; ") else NA
  singular_flag <- if (isSingular(m, tol=1e-4)) "singular" else NA

  data.frame(Biomarker = var,
             AIC = aic, BIC = bic,
             Marginal_R2 = r2$marginal,
             Conditional_R2 = r2$conditional,
             RandomInterceptVar = rand_intercept,
             RandomSlopeVar = rand_slope,
             ConvergenceWarning = conv_warn,
             SingularFit = singular_flag)
})
diagnostics_df <- do.call(rbind, diagnostics_list)
write.csv(diagnostics_df, "Diagnostics/Bioimpedance_LME_diagnostics.csv", row.names = FALSE)


```