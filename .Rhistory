elapsed_years = seq(min(data[[time_var]], na.rm = TRUE), max(data[[time_var]], na.rm = TRUE), length.out = n_points),
Change_Type = levels(data[[group_var]])
)
for (cov in covariates) {
if (is.numeric(data[[cov]])) {
newdata[[cov]] <- median(data[[cov]], na.rm = TRUE)
} else if (is.factor(data[[cov]])) {
newdata[[cov]] <- levels(data[[cov]])[1]
}
}
# Predict fixed effects only
newdata$predicted <- predict(mod, newdata = newdata, re.form = NA)
fixef_summary <- summary(mod)$coefficients
fixef_df <- as.data.frame(fixef_summary)
fixef_df$Term <- rownames(fixef_df)
sig_stars <- function(p) {
if (p < 0.001) "***"
else if (p < 0.01) "**"
else if (p < 0.05) "*"
else ""
}
fixef_df$stars <- sapply(fixef_df$`Pr(>|t|)`, sig_stars)
fixef_df$label <- paste0(fixef_df$Term, ": ", round(fixef_df$Estimate, 3), " ", fixef_df$stars)
print(fixef_df)
y_top <- max(newdata$predicted, na.rm = TRUE)
y_spacing <- (y_top - min(newdata$predicted, na.rm = TRUE)) * 0.05
y_positions <- seq(y_top, y_top - y_spacing * (nrow(fixef_df)-1), length.out = nrow(fixef_df))
annot_df <- data.frame(
x = rep(min(newdata[[time_var]]), nrow(fixef_df)),
y = y_positions,
label = fixef_df$label
)
p <- ggplot(newdata, aes_string(x = time_var, y = "predicted", color = group_var)) +
geom_line(size = 1.2) +
geom_text(data = annot_df, aes(x = x, y = y, label = label), hjust = 0, size = 3, inherit.aes = FALSE) +
labs(title = paste("Predicted", response, "Trajectories by", group_var),
x = time_var,
y = paste("Predicted", response)) +
theme_minimal()
print(summary(mod))
print(p)
return(list(model = mod, plot = p))
}
# Run models and plots for all BIA variables
results_list <- lapply(bia_vars, function(var) {
cat("\nAnalyzing variable:", var, "\n")
plot_lmer_predictions_with_stats(df_long.analysis, response = var)
})
# Example: print plot for bmi
print(results_list[[which(bia_vars == "bmi")]]$plot)
library(lmerTest)  # load this instead of lme4 for fitted model
plot_lmer_predictions_with_stats <- function(data, response = "PA_lower",
xvar = "elapsed_years", groupvar = "Group",
covariates = c("AGE", "SEX", "EDUYR"),
n_points = 100) {
# Fit the model with lmerTest to get p-values
formula_str <- paste0(response, " ~ ", xvar, "*", groupvar, " + ",
paste(covariates, collapse = " + "), " + (1 + ", xvar, " | USUBJID)")
mod <- lmer(as.formula(formula_str), data = data)
# Create prediction data
newdata <- expand.grid(
elapsed_years = seq(min(data[[xvar]], na.rm = TRUE), max(data[[xvar]], na.rm = TRUE), length.out = n_points),
Group = unique(data[[groupvar]])
)
for (cov in covariates) {
if (is.numeric(data[[cov]])) {
newdata[[cov]] <- median(data[[cov]], na.rm = TRUE)
} else if (is.factor(data[[cov]])) {
newdata[[cov]] <- levels(data[[cov]])[1]
}
}
# Predict fixed effects
newdata$predicted <- predict(mod, newdata = newdata, re.form = NA)
# Extract coefficients with p-values
fixef_summary <- summary(mod)$coefficients
fixef_df <- as.data.frame(fixef_summary)
fixef_df$Term <- rownames(fixef_df)
sig_stars <- function(p) {
if (p < 0.001) "***" else if (p < 0.01) "**" else if (p < 0.05) "*" else ""
}
fixef_df$stars <- sapply(fixef_df$`Pr(>|t|)`, sig_stars)
fixef_df$label <- paste0(fixef_df$Term, ": ", round(fixef_df$Estimate, 3), " ", fixef_df$stars)
print(fixef_df)
y_top <- max(newdata$predicted, na.rm = TRUE)
y_spacing <- (y_top - min(newdata$predicted, na.rm = TRUE)) * 0.05
y_positions <- seq(y_top, y_top - y_spacing * (nrow(fixef_df) - 1), length.out = nrow(fixef_df))
annot_df <- data.frame(
x = rep(min(newdata[[xvar]]), nrow(fixef_df)),
y = y_positions,
label = fixef_df$label
)
p <- ggplot(newdata, aes_string(x = xvar, y = "predicted", color = groupvar)) +
geom_line(size = 1.2) +
geom_text(data = annot_df, aes(x = x, y = y, label = label), hjust = 0, size = 3, inherit.aes = FALSE) +
labs(title = paste("Predicted", response, "Trajectories by", groupvar),
x = xvar,
y = paste("Predicted", response)) +
theme_minimal()
print(summary(mod))
return(p)
}
plot_lmer_predictions_with_stats(df_long.analysis, response="theta")
library(lmerTest)  # load this instead of lme4 for fitted model
plot_lmer_predictions_with_stats <- function(data, response = "PA_lower",
xvar = "elapsed_years", groupvar = "Group",
covariates = c("AGE", "SEX", "EDUYR"),
n_points = 100) {
# Fit the model with lmerTest to get p-values
formula_str <- paste0(response, " ~ ", xvar, "*", groupvar, " + ",
paste(covariates, collapse = " + "), " + (1 + ", xvar, " | USUBJID)")
mod <- lmer(as.formula(formula_str), data = data)
# Create prediction data
newdata <- expand.grid(
elapsed_years = seq(min(data[[xvar]], na.rm = TRUE), max(data[[xvar]], na.rm = TRUE), length.out = n_points),
Group = unique(data[[groupvar]])
)
for (cov in covariates) {
if (is.numeric(data[[cov]])) {
newdata[[cov]] <- median(data[[cov]], na.rm = TRUE)
} else if (is.factor(data[[cov]])) {
newdata[[cov]] <- levels(data[[cov]])[1]
}
}
# Predict fixed effects
newdata$predicted <- predict(mod, newdata = newdata, re.form = NA)
# Extract coefficients with p-values
fixef_summary <- summary(mod)$coefficients
fixef_df <- as.data.frame(fixef_summary)
fixef_df$Term <- rownames(fixef_df)
sig_stars <- function(p) {
if (p < 0.001) "***" else if (p < 0.01) "**" else if (p < 0.05) "*" else ""
}
fixef_df$stars <- sapply(fixef_df$`Pr(>|t|)`, sig_stars)
fixef_df$label <- paste0(fixef_df$Term, ": ", round(fixef_df$Estimate, 3), " ", fixef_df$stars)
print(fixef_df)
y_top <- max(newdata$predicted, na.rm = TRUE)
y_spacing <- (y_top - min(newdata$predicted, na.rm = TRUE)) * 0.05
y_positions <- seq(y_top, y_top - y_spacing * (nrow(fixef_df) - 1), length.out = nrow(fixef_df))
annot_df <- data.frame(
x = rep(min(newdata[[xvar]]), nrow(fixef_df)),
y = y_positions,
label = fixef_df$label
)
p <- ggplot(newdata, aes_string(x = xvar, y = "predicted", color = groupvar)) +
geom_line(size = 1.2) +
geom_text(data = annot_df, aes(x = x, y = y, label = label), hjust = 0, size = 3, inherit.aes = FALSE) +
labs(title = paste("Predicted", response, "Trajectories by", groupvar),
x = xvar,
y = paste("Predicted", response)) +
theme_minimal()
print(summary(mod))
return(p)
}
plot_lmer_predictions_with_stats(df_long.analysis, response="PA_upper")
library(lmerTest)
# Fit random intercept and slope LME model
mod <- lmer(whr ~ elapsed_years*Change_Type  + AGE + SEX + EDUYR  + (1 + elapsed_years| USUBJID), data = df_long.analysis, REML = TRUE)
summary(mod)
library(emmeans)
library(broom.mixed)
analyze_longitudinal_trends <- function(data,
response = "bmi",
xvar = "elapsed_years",
groupvar = "Group",
covariates = c("AGE", "SEX", "EDUYR"),
subject_id = "USUBJID",
time_points_input = c(0,1,2,3,4,5,6),
reference_group = NULL,
comparison_groups = NULL) {
# Ensure groupvar is factor
if(!is.factor(data[[groupvar]])) {
data[[groupvar]] <- as.factor(data[[groupvar]])
}
# Set reference group to first level if NULL
group_levels <- levels(data[[groupvar]])
if(is.null(reference_group)) reference_group <- group_levels[1]
# Set comparison groups to all others except reference if NULL
if(is.null(comparison_groups)) comparison_groups <- setdiff(group_levels, reference_group)
# Validate that specified groups exist
if(!(reference_group %in% group_levels)) stop("Reference group not in groupvar levels")
if(!all(comparison_groups %in% group_levels)) stop("Some comparison groups not in groupvar levels")
# Linear mixed model formula
fixed_effects <- paste0(xvar, "*", groupvar, " + ", paste(covariates, collapse = " + "))
random_effects <- paste0("(1 + ", xvar, " | ", subject_id, ")")
formula_str <- paste0(response, " ~ ", fixed_effects, " + ", random_effects)
# Fit model
mod <- lmer(as.formula(formula_str), data = data)
# Residual SD (for Cohen's d)
sigma_resid <- sigma(mod)
emt <- emtrends(mod, specs = groupvar, var = xvar)
summary_emt <- summary(emt, infer = TRUE)
trend_col <- grep("\\.trend$", colnames(summary_emt), value = TRUE)
if(length(trend_col) != 1) stop("Unexpected number of trend columns in emtrends output")
contrasts_df <- contrast(emt, method = "pairwise") %>%
summary(infer = TRUE, adjust = "tukey")
slope_tests <- summary_emt %>%
dplyr::rename(
slope = !!rlang::sym(trend_col),
group = !!rlang::sym(groupvar)
) %>%
dplyr::select(group, slope, SE, df, t.ratio, p.value, lower.CL, upper.CL)
# Extract slopes and p-values for ref and comparisons
extract_stats <- function(g) {
d <- slope_tests %>% dplyr::filter(group == g)
if(nrow(d) == 0) stop(paste("Group", g, "not found in slope tests"))
list(slope = d$slope, p_zero = d$p.value)
}
ref_stats <- extract_stats(reference_group)
comp_stats <- lapply(comparison_groups, extract_stats)
names(comp_stats) <- comparison_groups
# Interaction p-values
fe <- broom.mixed::tidy(mod, effects = "fixed") %>% dplyr::select(term, p.value)
interaction_pvals <- sapply(comparison_groups, function(g){
term <- paste0(xvar, ":", groupvar, g)
val <- fe %>% dplyr::filter(term == !!term) %>% dplyr::pull(p.value)
if(length(val)==0) NA_real_ else val
})
# Cohen's d for each comparison slope difference
cohens_d <- sapply(comparison_groups, function(g){
(comp_stats[[g]]$slope - ref_stats$slope) / sigma_resid
})
# Time points in observed range
max_elapsed <- max(data[[xvar]], na.rm = TRUE)
time_points <- sort(time_points_input[time_points_input <= max_elapsed])
if(length(time_points) == 0) {
warning("No time points within observed range, using 0")
time_points <- 0
}
# Prepare trends table with all groups
trends <- tibble::tibble(Year = time_points) %>%
dplyr::mutate(!!paste0(response, "_", reference_group, "_change") := ref_stats$slope * Year)
for(g in comparison_groups) {
slopes <- comp_stats[[g]]$slope
trends <- trends %>%
dplyr::mutate(
!!paste0(response, "_", g, "_change") := slopes * Year,
!!paste0("Difference_", g, "_vs_", reference_group) := (slopes - ref_stats$slope) * Year,
!!paste0("Cohen_d_diff_", g, "_vs_", reference_group) := cohens_d[g] * Year
)
}
trends <- trends %>% dplyr::mutate(across(-Year, ~round(., 3)))
# Model summary table
model_summary <- tibble::tibble(
Outcome = response,
Measure = "Annual change (linear trend)",
!!paste0(reference_group, "_slope") := round(ref_stats$slope,4),
!!paste0(reference_group, "_p_zero") := round(ref_stats$p_zero,4),
Residual_SD = round(sigma_resid, 3)
)
for(g in comparison_groups) {
model_summary[[paste0(g,"_slope")]] <- round(comp_stats[[g]]$slope,4)
model_summary[[paste0(g,"_p_zero")]] <- round(comp_stats[[g]]$p_zero,4)
model_summary[[paste0("p_diff_slopes_", g, "_vs_", reference_group)]] <- round(interaction_pvals[g],4)
model_summary[[paste0("Cohen_d_diff_", g, "_vs_", reference_group)]] <- round(cohens_d[g],3)
}
list(
trends = trends,
model_summary = model_summary,
model = mod,
slope_tests = slope_tests,
contrasts_df = contrasts_df
)
}
#Plot the slopes
plot_slopes <- function(model_summary_list,  colors = c("CN" = "#00BFC4", "MCI" = "#F8766D")) {
# Combine all model summaries
all_summaries <- bind_rows(model_summary_list)
# Identify slope and p-value columns by pattern
slope_cols <- grep("_slope$", colnames(all_summaries), value = TRUE)
pval_cols <- grep("_p_zero$", colnames(all_summaries), value = TRUE)
# Extract outcome variable from 'Outcome' column
outcomes <- all_summaries$Outcome
# Pivot slopes longer
slopes_long <- all_summaries %>%
dplyr::select(Outcome, all_of(slope_cols)) %>%
tidyr::pivot_longer(cols = -Outcome, names_to = "Group", values_to = "slope") %>%
dplyr::mutate(Group = sub("_slope$", "", Group))
# Pivot p-values longer
pvals_long <- all_summaries %>%
dplyr::select(Outcome, all_of(pval_cols)) %>%
tidyr::pivot_longer(cols = -Outcome, names_to = "Group", values_to = "p_value") %>%
dplyr::mutate(Group = sub("_p_zero$", "", Group))
# Join slopes and p-values
plot_data <- dplyr::left_join(slopes_long, pvals_long, by = c("Outcome", "Group"))
# Significance labels (customize as needed)
plot_data <- plot_data %>%
dplyr::mutate(
sig = case_when(
p_value < 0.001 ~ "***",
p_value < 0.01  ~ "**",
p_value <= 0.05 ~ "*",
TRUE ~ ""
),
label = paste0(round(slope, 3), sig)
)
# Use default colors if not provided
if (is.null(colors)) {
groups <- unique(plot_data$Group)
palette <- scales::hue_pal()(length(groups))
colors <- setNames(palette, groups)
}
dodge_width <- 0.8
ggplot(plot_data, aes(x = Outcome, y = slope, fill = Group)) +
geom_col(position = position_dodge2(width = dodge_width), width = dodge_width, alpha = 0.8) +
geom_text(aes(label = label), position = position_dodge2(width = dodge_width), vjust = -0.5, size = 3) +
geom_hline(yintercept = 0, linetype = "dashed", color = "gray") +
labs(title = "Annual Change in Outcomes by Group",
y = "Slope",
x = "Biormarker") +
scale_fill_manual(values = colors) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
legend.position = "top")
}
#Plot the p-Values of the LME
plot_pvalues <- function(model_summary_list, pvalue_pattern = "^p_diff_slopes") {
all_summaries <- bind_rows(model_summary_list)
# Find column matching the pattern for p-values
pval_col <- grep(pvalue_pattern, colnames(all_summaries), value = TRUE)
if(length(pval_col) == 0) stop("No p-value column matching pattern found")
if(length(pval_col) > 1) {
warning("Multiple p-value columns matched, using the first: ", pval_col[1])
pval_col <- pval_col[1]
}
p_df <- all_summaries %>%
dplyr::select(Outcome, !!rlang::sym(pval_col)) %>%
dplyr::rename(p_value = !!rlang::sym(pval_col)) %>%
dplyr::mutate(
log10_p = -log10(pmax(p_value, 1e-10)),
sig = dplyr::case_when(
p_value < 0.001 ~ "***",
p_value < 0.01  ~ "**",
p_value <= 0.05 ~ "*",
TRUE ~ ""
)
) %>%
dplyr::arrange(desc(log10_p))
ggplot(p_df, aes(x = reorder(Outcome, log10_p), y = log10_p)) +
geom_col(fill = "steelblue", alpha = 0.7) +
geom_text(aes(label = paste0(round(p_value, 3), sig)),
hjust = -0.12, size = 3, vjust = -0.2) +
geom_hline(yintercept = -log10(0.05), color = "red", linetype = "dashed", alpha = 0.7) +
geom_hline(yintercept = -log10(0.01), color = "orange", linetype = "dotted", alpha = 0.5) +
geom_hline(yintercept = -log10(0.001), color = "darkred", linetype = "dotdash", alpha = 0.5) +
labs(title = "Significance of Group-by-Time Interaction",
subtitle = "Dashed line: p = 0.05 | Dotted: p = 0.01 | Dash-dot: p = 0.001",
y = expression(-log10),
x = "Outcome") +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
plot.margin = margin(t = 10, r = 50, b = 10, l = 10),  # Slightly more right margin
plot.subtitle = element_text(size = 9, color = "gray50")
) +
coord_cartesian(clip = "off")
}
library(lmerTest)  # load this instead of lme4 for fitted model
plot_lmer_predictions_with_stats <- function(data, response = "PA_lower",
xvar = "elapsed_years", groupvar = "Change_type",
covariates = c("AGE", "SEX", "EDUYR"),
n_points = 100) {
# Fit the model with lmerTest to get p-values
formula_str <- paste0(response, " ~ ", xvar, "*", groupvar, " + ",
paste(covariates, collapse = " + "), " + (1 + ", xvar, " | USUBJID)")
mod <- lmer(as.formula(formula_str), data = data)
# Create prediction data
newdata <- expand.grid(
elapsed_years = seq(min(data[[xvar]], na.rm = TRUE), max(data[[xvar]], na.rm = TRUE), length.out = n_points),
Group = unique(data[[groupvar]])
)
for (cov in covariates) {
if (is.numeric(data[[cov]])) {
newdata[[cov]] <- median(data[[cov]], na.rm = TRUE)
} else if (is.factor(data[[cov]])) {
newdata[[cov]] <- levels(data[[cov]])[1]
}
}
# Predict fixed effects
newdata$predicted <- predict(mod, newdata = newdata, re.form = NA)
# Extract coefficients with p-values
fixef_summary <- summary(mod)$coefficients
fixef_df <- as.data.frame(fixef_summary)
fixef_df$Term <- rownames(fixef_df)
sig_stars <- function(p) {
if (p < 0.001) "***" else if (p < 0.01) "**" else if (p < 0.05) "*" else ""
}
fixef_df$stars <- sapply(fixef_df$`Pr(>|t|)`, sig_stars)
fixef_df$label <- paste0(fixef_df$Term, ": ", round(fixef_df$Estimate, 3), " ", fixef_df$stars)
print(fixef_df)
y_top <- max(newdata$predicted, na.rm = TRUE)
y_spacing <- (y_top - min(newdata$predicted, na.rm = TRUE)) * 0.05
y_positions <- seq(y_top, y_top - y_spacing * (nrow(fixef_df) - 1), length.out = nrow(fixef_df))
annot_df <- data.frame(
x = rep(min(newdata[[xvar]]), nrow(fixef_df)),
y = y_positions,
label = fixef_df$label
)
p <- ggplot(newdata, aes_string(x = xvar, y = "predicted", color = groupvar)) +
geom_line(size = 1.2) +
geom_text(data = annot_df, aes(x = x, y = y, label = label), hjust = 0, size = 3, inherit.aes = FALSE) +
labs(title = paste("Predicted", response, "Trajectories by", groupvar),
x = xvar,
y = paste("Predicted", response)) +
theme_minimal()
print(summary(mod))
return(p)
}
plot_lmer_predictions_with_stats(df_long.analysis, response="PA_upper")
library(lmerTest)  # load this instead of lme4 for fitted model
plot_lmer_predictions_with_stats <- function(data, response = "PA_lower",
xvar = "elapsed_years", groupvar = "Change_Type",
covariates = c("AGE", "SEX", "EDUYR"),
n_points = 100) {
# Fit the model with lmerTest to get p-values
formula_str <- paste0(response, " ~ ", xvar, "*", groupvar, " + ",
paste(covariates, collapse = " + "), " + (1 + ", xvar, " | USUBJID)")
mod <- lmer(as.formula(formula_str), data = data)
# Create prediction data
newdata <- expand.grid(
elapsed_years = seq(min(data[[xvar]], na.rm = TRUE), max(data[[xvar]], na.rm = TRUE), length.out = n_points),
Group = unique(data[[groupvar]])
)
for (cov in covariates) {
if (is.numeric(data[[cov]])) {
newdata[[cov]] <- median(data[[cov]], na.rm = TRUE)
} else if (is.factor(data[[cov]])) {
newdata[[cov]] <- levels(data[[cov]])[1]
}
}
# Predict fixed effects
newdata$predicted <- predict(mod, newdata = newdata, re.form = NA)
# Extract coefficients with p-values
fixef_summary <- summary(mod)$coefficients
fixef_df <- as.data.frame(fixef_summary)
fixef_df$Term <- rownames(fixef_df)
sig_stars <- function(p) {
if (p < 0.001) "***" else if (p < 0.01) "**" else if (p < 0.05) "*" else ""
}
fixef_df$stars <- sapply(fixef_df$`Pr(>|t|)`, sig_stars)
fixef_df$label <- paste0(fixef_df$Term, ": ", round(fixef_df$Estimate, 3), " ", fixef_df$stars)
print(fixef_df)
y_top <- max(newdata$predicted, na.rm = TRUE)
y_spacing <- (y_top - min(newdata$predicted, na.rm = TRUE)) * 0.05
y_positions <- seq(y_top, y_top - y_spacing * (nrow(fixef_df) - 1), length.out = nrow(fixef_df))
annot_df <- data.frame(
x = rep(min(newdata[[xvar]]), nrow(fixef_df)),
y = y_positions,
label = fixef_df$label
)
p <- ggplot(newdata, aes_string(x = xvar, y = "predicted", color = groupvar)) +
geom_line(size = 1.2) +
geom_text(data = annot_df, aes(x = x, y = y, label = label), hjust = 0, size = 3, inherit.aes = FALSE) +
labs(title = paste("Predicted", response, "Trajectories by", groupvar),
x = xvar,
y = paste("Predicted", response)) +
theme_minimal()
print(summary(mod))
return(p)
}
plot_lmer_predictions_with_stats(df_long.analysis, response="PA_upper")
library(lmerTest)  # load this instead of lme4 for fitted model
plot_lmer_predictions_with_stats <- function(data, response = "PA_lower",
xvar = "elapsed_years", groupvar = "Group",
covariates = c("AGE", "SEX", "EDUYR"),
n_points = 100) {
# Fit the model with lmerTest to get p-values
formula_str <- paste0(response, " ~ ", xvar, "*", groupvar, " + ",
paste(covariates, collapse = " + "), " + (1 + ", xvar, " | USUBJID)")
mod <- lmer(as.formula(formula_str), data = data)
# Create prediction data
newdata <- expand.grid(
elapsed_years = seq(min(data[[xvar]], na.rm = TRUE), max(data[[xvar]], na.rm = TRUE), length.out = n_points),
Group = unique(data[[groupvar]])
)
for (cov in covariates) {
if (is.numeric(data[[cov]])) {
newdata[[cov]] <- median(data[[cov]], na.rm = TRUE)
} else if (is.factor(data[[cov]])) {
newdata[[cov]] <- levels(data[[cov]])[1]
}
}
# Predict fixed effects
newdata$predicted <- predict(mod, newdata = newdata, re.form = NA)
# Extract coefficients with p-values
fixef_summary <- summary(mod)$coefficients
fixef_df <- as.data.frame(fixef_summary)
fixef_df$Term <- rownames(fixef_df)
sig_stars <- function(p) {
if (p < 0.001) "***" else if (p < 0.01) "**" else if (p < 0.05) "*" else ""
}
fixef_df$stars <- sapply(fixef_df$`Pr(>|t|)`, sig_stars)
fixef_df$label <- paste0(fixef_df$Term, ": ", round(fixef_df$Estimate, 3), " ", fixef_df$stars)
print(fixef_df)
y_top <- max(newdata$predicted, na.rm = TRUE)
y_spacing <- (y_top - min(newdata$predicted, na.rm = TRUE)) * 0.05
y_positions <- seq(y_top, y_top - y_spacing * (nrow(fixef_df) - 1), length.out = nrow(fixef_df))
annot_df <- data.frame(
x = rep(min(newdata[[xvar]]), nrow(fixef_df)),
y = y_positions,
label = fixef_df$label
)
p <- ggplot(newdata, aes_string(x = xvar, y = "predicted", color = groupvar)) +
geom_line(size = 1.2) +
geom_text(data = annot_df, aes(x = x, y = y, label = label), hjust = 0, size = 3, inherit.aes = FALSE) +
labs(title = paste("Predicted", response, "Trajectories by", groupvar),
x = xvar,
y = paste("Predicted", response)) +
theme_minimal()
print(summary(mod))
return(p)
}
plot_lmer_predictions_with_stats(df_long.analysis, response="PA_upper")
