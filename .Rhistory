})
# Output summary: robust to missing pairwise
meta_rows <- lapply(comparisongroups, function(g) {
contrastA <- paste(referencegroup, g, sep = " - ")
contrastB <- paste(g, referencegroup, sep = " - ")
idx <- which(sum_contrast$contrast %in% c(contrastA, contrastB))
if(length(idx)==1 && nrow(refstats)==1 && nrow(compstats[[g]])==1) {
# If the contrast is "g - referencegroup", flip sign
sign_mult <- if (sum_contrast$contrast[idx] == contrastA) 1 else -1
tibble(
Outcome = response,
Comparison = paste(g, "vs", referencegroup),
Slope_Ref = round(refstats$slope, 4),
Slope_Comp = round(compstats[[g]]$slope, 4),
Slope_Diff = round(sign_mult * sum_contrast$estimate[idx], 4),
Slope_SE = round(sum_contrast$SE[idx], 4),
Slope_Lower = round(sign_mult * sum_contrast$lower.CL[idx], 4),
Slope_Upper = round(sign_mult * sum_contrast$upper.CL[idx], 4),
Slope_p = round(sum_contrast$p.value[idx], 5),
Cohen_d = round(cohensd[g], 4),
Wald_p = round(wald_p, 5),
LRT_p = round(lrt_p, 5),
LRT_chi = round(lrt_chi, 3),
LRT_df = lrt_df,
ResidualSD = round(sigma_resid, 3)
)
} else {
tibble(
Outcome = response,
Comparison = paste(g, "vs", referencegroup),
Slope_Ref = NA, Slope_Comp = NA, Slope_Diff = NA,
Slope_SE = NA, Slope_Lower = NA, Slope_Upper = NA,
Slope_p = NA, Cohen_d = NA, Wald_p = NA,
LRT_p = NA, LRT_chi = NA, LRT_df = NA, ResidualSD = NA
)
}
})
modelsummary <- bind_rows(meta_rows)
list(
modelsummary = modelsummary,
mod_full = mod_full,
mod_noint = mod_noint,
lrt = lrt,
wald_p = wald_p,
slopes = sum_emt,
contrast = sum_contrast,
cohensd = cohensd
)
}
# --- List of Markers ---
biavars <- c(
"MMSE", "SNSB_attention", "SNSB_language", "SNSB_visuospatial", "SNSB_memory", "SNSB_frontal",
"bmi", "whr", "pbcm", "pbf", "bmr", "ecw_tcw", "tbw_ffm", "PA50_total",
"ECW_ICW_upper", "ECW_ICW_lower", "Water_Lean_upper", "Water_Lean_lower",
"R_upper", "R_lower", "Xc_upper", "Xc_lower", "PA_upper", "PA_lower",
"R_H_upper", "R_H_lower", "Xc_H_upper", "Xc_H_lower"
)
# --- Batch Analysis ---
results <- lapply(biavars, function(var) {
print(paste("Analyzing:", var))
analyze_longitudinal_trends_LRT(
data = df_long.analysis,
response = var,
groupvar = "Change_Type",
referencegroup = referencegroup,
comparisongroups = comparisongroups
)
})
modelsummarylist <- lapply(results, function(x) x$modelsummary)
allsummaries <- bind_rows(modelsummarylist, .id = "Biomarker")
write.csv(allsummaries, "Bioimpedance_LME_LRT_summary.csv", row.names = FALSE)
print("Check complete: Output summary table written!")
# --- Batch Plot Generation (Wald + LRT) ---
output_dir_wald <- "Bioimpedance_Trajectory_WaldPlots"
output_dir_lrt <- "Bioimpedance_Trajectory_LRTPlots"
dir.create(output_dir_wald, showWarnings = FALSE)
dir.create(output_dir_lrt, showWarnings = FALSE)
plots_wald <- lapply(biavars, function(var)
plot_lmer_model_with_interaction_p(
data = df_long.analysis,
response = var,
colors = colors.legend
)
)
plots_lrt <- lapply(biavars, function(var)
plot_lmer_interaction_with_p(
data = df_long.analysis,
response = var,
colors = colors.legend,
show.legend = FALSE
)
)
for (i in seq_along(biavars)) {
pw <- plots_wald[[i]]
pl <- plots_lrt[[i]]
if (inherits(pw, "ggplot")) {
ggsave(
filename = file.path(output_dir_wald, paste0(biavars[i], "_waldplot.png")),
plot = pw, width = 7, height = 5, dpi = 300
)
}
if (inherits(pl, "ggplot")) {
ggsave(
filename = file.path(output_dir_lrt, paste0(biavars[i], "_lrtplot.png")),
plot = pl, width = 7, height = 5, dpi = 300
)
}
}
# --- Setup ---
library(dplyr)
library(tibble)
library(effsize)
library(emmeans)
output_dir <- "Baseline_Results"
if (!dir.exists(output_dir)) dir.create(output_dir)
df_baseline <- df4 %>%
filter(Change_Type %in% c("StableCN", "CNtransitMCI")) %>%
group_by(USUBJID) %>%
filter(datetest == min(datetest)) %>%
ungroup()
df_baseline$SEX <- as.factor(df_baseline$SEX)
df_baseline$Change_Type <- as.factor(df_baseline$Change_Type)
#write.csv(df_baseline, "df_baseline.csv",row.names = FALSE)
vars_table1 <- c('SEX','AGE','EDUYR','gds','visit_count','MMSE',
'SNSB_attention','SNSB_language','SNSB_visuospatial','SNSB_memory','SNSB_frontal')
vars_table2 <- c('height','weight','Waistcir','Hipcir','sysbp','diabp','bmi','ac','whr',
'pbcm','pbf','bmr','tbw_ffm','ecw_tcw','PA50_total')
vars_table3 <- c('ECW_ICW_upper','ECW_ICW_lower','Water_Lean_upper','Water_Lean_lower',
'R_upper','R_lower','Xc_upper','Xc_lower','PA_upper','PA_lower',
'R_H_upper','R_H_lower','Xc_H_upper','Xc_H_lower')
group_var <- "Change_Type"
covars <- c("AGE", "SEX", "EDUYR")
# --- Table 1: Descriptive & Inferential ---
get_group_summary <- function(v, df) {
vals <- df[[v]]
grp <- df[[group_var]]
n_grp1 <- sum(grp == levels(grp)[1] & !is.na(vals))
n_grp2 <- sum(grp == levels(grp)[2] & !is.na(vals))
# For continuous
if (is.numeric(vals) | is.integer(vals)) {
p_norm <- tryCatch(shapiro.test(vals)$p.value, error=function(e) NA)
fun_stat <- function(x, is_normal) {
if (!is.na(is_normal) && is_normal > 0.05) {
m <- mean(x, na.rm=TRUE)
s <- sd(x, na.rm=TRUE)
return(sprintf("%.1f (%.1f)", m, s))
} else {
md <- median(x, na.rm=TRUE)
iq <- IQR(x, na.rm=TRUE)
return(sprintf("%.1f [%.1f]", md, iq))
}
}
stats <- sapply(levels(grp), function(g) fun_stat(vals[grp==g], p_norm))
nvals <- sapply(levels(grp), function(g) sum(!is.na(vals[grp==g])))
names(stats) <- levels(grp)
stat_with_n <- paste0(stats, " [n=", nvals, "]")
return(stat_with_n)
} else {
# For categorical: n (%)
lvl <- levels(as.factor(vals))
# Summarize all levels for robustness
stats_cat <- sapply(levels(grp), function(g) {
tot <- sum(grp==g & !is.na(vals))
lv_counts <- sapply(lvl, function(lv) sum(vals==lv & grp==g, na.rm=TRUE))
lv_perc <- round(100*lv_counts/tot, 1)
paste(mapply(function(n,p,l) sprintf("%s: %d (%.1f%%)", l,n,p), lv_counts, lv_perc, lvl), collapse=" / ")
})
names(stats_cat) <- levels(grp)
return(stats_cat)
}
}
cramerV <- function(tab){
chi2 <- suppressWarnings(chisq.test(tab)$statistic)
n <- sum(tab)
min_dim <- min(dim(tab)) - 1
sqrt(as.numeric(chi2)/(n*min_dim))
}
get_pvals_es <- function(varlist, groupvar, df){
res <- lapply(varlist, function(v){
vals <- df[[v]]; g <- df[[groupvar]]
non_missing <- !(is.na(vals) | is.na(g))
vals_nm <- vals[non_missing]
g_nm <- g[non_missing]
n_grp <- table(g_nm)
if (length(unique(g_nm)) != 2) return(list(test=NA, pval=NA, effsize=NA, n1=NA, n2=NA))
if (is.numeric(vals_nm) | is.integer(vals_nm)){
p_norm <- tryCatch(shapiro.test(vals_nm)$p.value, error=function(e) NA)
n1 <- sum(g_nm == levels(as.factor(g_nm))[1])
n2 <- sum(g_nm == levels(as.factor(g_nm))[2])
if (!is.na(p_norm) && p_norm > 0.05){
ttest <- t.test(vals_nm ~ g_nm)
# Effect size: also provide Hedges' g for transparency
cd <- effsize::cohen.d(vals_nm, g_nm)$estimate
hg <- effsize::hedges.g(vals_nm, g_nm)$estimate
return(list(test="Welch t", pval=ttest$p.value, cohen_d=cd, hedges_g=hg, n1=n1, n2=n2))
}else{
wilcox <- wilcox.test(vals_nm ~ g_nm)
cd <- effsize::cohen.d(vals_nm, g_nm, hedges.correction=TRUE)$estimate
hg <- effsize::hedges.g(vals_nm, g_nm)$estimate
return(list(test="Mann–Whitney", pval=wilcox$p.value, cohen_d=cd, hedges_g=hg, n1=n1, n2=n2))
}
}else{
tbl <- table(vals_nm, g_nm)
n1 <- sum(g_nm == levels(as.factor(g_nm))[1])
n2 <- sum(g_nm == levels(as.factor(g_nm))[2])
if(any(tbl < 5)) {
test <- "Fisher"
pval <- fisher.test(tbl)$p.value
} else {
test <- "ChiSquare"
pval <- chisq.test(tbl)$p.value
}
cv <- tryCatch(cramerV(tbl), error = function(e) NA)
return(list(test=test, pval=pval, cramerV=cv, n1=n1, n2=n2))
}
})
names(res) <- varlist
return(res)
}
result_tab1 <- get_pvals_es(vars_table1, group_var, df_baseline)
# --- Setup ---
library(dplyr)
library(tibble)
library(effsize)
library(emmeans)
output_dir <- "Baseline_Results"
if (!dir.exists(output_dir)) dir.create(output_dir)
df_baseline <- df4 %>%
filter(Change_Type %in% c("StableCN", "CNtransitMCI")) %>%
group_by(USUBJID) %>%
filter(datetest == min(datetest)) %>%
ungroup()
df_baseline$SEX <- as.factor(df_baseline$SEX)
df_baseline$Change_Type <- factor(df_baseline$Change_Type, levels = c("StableCN", "CNtransitMCI")) # ensure order!
vars_table1 <- c('SEX','AGE','EDUYR','gds','visit_count','MMSE',
'SNSB_attention','SNSB_language','SNSB_visuospatial','SNSB_memory','SNSB_frontal')
group_var <- "Change_Type"
# --- Table 1: Descriptive stats by group + inferential stats ---
get_group_summary <- function(v, df) {
vals <- df[[v]]
grp <- df[[group_var]]
lvls <- levels(grp)
# For continuous/discrete
if (is.numeric(vals) | is.integer(vals)) {
p_norm <- tryCatch(shapiro.test(vals)$p.value, error=function(e) NA)
fun_stat <- function(x, is_normal) {
if (!is.na(is_normal) && is_normal > 0.05) {
m <- mean(x, na.rm=TRUE); s <- sd(x, na.rm=TRUE)
sprintf("%.1f (%.1f)", m, s)
} else {
md <- median(x, na.rm=TRUE); iq <- IQR(x, na.rm=TRUE)
sprintf("%.1f [%.1f]", md, iq)
}
}
stats <- sapply(lvls, function(g) fun_stat(vals[grp==g], p_norm))
nvals <- sapply(lvls, function(g) sum(!is.na(vals[grp==g])))
stat_with_n <- paste0(stats, " [n=", nvals, "]")
return(stat_with_n)
} else {
# For categorical: n (%)
levels_cat <- levels(as.factor(vals))
stats_cat <- sapply(lvls, function(g) {
tot <- sum(grp==g & !is.na(vals))
lv_counts <- sapply(levels_cat, function(lv) sum((vals==lv) & (grp==g), na.rm=TRUE))
lv_perc <- round(100*lv_counts/tot,1)
paste(mapply(function(n, p, l) sprintf("%s: %d (%.1f%%)", l, n, p), lv_counts, lv_perc, levels_cat), collapse=" / ")
})
return(stats_cat)
}
}
cramerV <- function(tab){
chi2 <- suppressWarnings(chisq.test(tab, correct=FALSE)$statistic)
n <- sum(tab)
min_dim <- min(dim(tab)) - 1
sqrt(as.numeric(chi2)/(n*min_dim))
}
get_pvals_es <- function(varlist, groupvar, df){
res <- lapply(varlist, function(v){
vals <- df[[v]]; g <- df[[group_var]]
lvls <- levels(as.factor(g))
non_missing <- !(is.na(vals) | is.na(g))
vals_nm <- vals[non_missing]; g_nm <- g[non_missing]
idx1 <- which(g_nm==lvls[1]); idx2 <- which(g_nm==lvls[2])
n1 <- length(idx1); n2 <- length(idx2)
# Only run if two groups (as in manuscript)
if (length(unique(g_nm)) != 2) return(list(test=NA, pval=NA, effectsize=NA, n1=n1, n2=n2))
if (is.numeric(vals_nm) | is.integer(vals_nm)){
p_norm <- tryCatch(shapiro.test(vals_nm)$p.value, error=function(e) NA)
group1 <- vals_nm[idx1]; group2 <- vals_nm[idx2]
# Effect size always group2-group1
if (!is.na(p_norm) && p_norm > 0.05){
ttest <- t.test(vals_nm ~ g_nm)
es <- tryCatch(effsize::cohen.d(vals_nm, g_nm, hedges.correction=TRUE)$estimate, error=function(e) NA)
return(list(test="Welch t", pval=ttest$p.value, effectsize=es, n1=n1, n2=n2))
} else {
wilcox <- wilcox.test(vals_nm ~ g_nm)
es <- tryCatch(effsize::cohen.d(vals_nm, g_nm, hedges.correction=TRUE)$estimate, error=function(e) NA)
return(list(test="Mann–Whitney", pval=wilcox$p.value, effectsize=es, n1=n1, n2=n2))
}
} else {
tbl <- table(vals_nm, g_nm)
if(any(tbl < 5)) {
test <- "Fisher"
pval <- fisher.test(tbl)$p.value
} else {
test <- "ChiSquare"
pval <- chisq.test(tbl)$p.value
}
es <- tryCatch(cramerV(tbl), error = function(e) NA)
return(list(test=test, pval=pval, effectsize=es, n1=n1, n2=n2))
}
})
names(res) <- varlist
return(res)
}
result_tab1 <- get_pvals_es(vars_table1, group_var, df_baseline)
tab1_journal <- tibble(
Variable = vars_table1,
StableCN = sapply(vars_table1, function(v) get_group_summary(v, df_baseline)[1]),
CNtransitMCI = sapply(vars_table1, function(v) get_group_summary(v, df_baseline)[2]),
N_StableCN = sapply(result_tab1, function(x) x$n1),
N_CNtransitMCI = sapply(result_tab1, function(x) x$n2),
Test = sapply(result_tab1, function(x) x$test),
PValue = sapply(result_tab1, function(x) x$pval),
EffectSize = sapply(result_tab1, function(x) x$effectsize)
)
write.csv(tab1_journal, file.path(output_dir, "table1_journalformat.csv"), row.names=FALSE)
# --- Setup ---
library(dplyr)
library(tibble)
library(effsize)
library(emmeans)
output_dir <- "Baseline_Results"
if (!dir.exists(output_dir)) dir.create(output_dir)
df_baseline <- df4 %>%
filter(Change_Type %in% c("StableCN", "CNtransitMCI")) %>%
group_by(USUBJID) %>%
filter(datetest == min(datetest)) %>%
ungroup()
df_baseline$SEX <- as.factor(df_baseline$SEX)
df_baseline$Change_Type <- factor(df_baseline$Change_Type, levels = c("StableCN", "CNtransitMCI")) # ensure order!
vars_table1 <- c('SEX','AGE','EDUYR','gds','visit_count','MMSE',
'SNSB_attention','SNSB_language','SNSB_visuospatial','SNSB_memory','SNSB_frontal')
group_var <- "Change_Type"
# --- Table 1: Descriptive stats by group + inferential stats ---
get_group_summary <- function(v, df) {
vals <- df[[v]]
grp <- df[[group_var]]
lvls <- levels(grp)
# For continuous/discrete
if (is.numeric(vals) | is.integer(vals)) {
p_norm <- tryCatch(shapiro.test(vals)$p.value, error=function(e) NA)
fun_stat <- function(x, is_normal) {
if (!is.na(is_normal) && is_normal > 0.05) {
m <- mean(x, na.rm=TRUE); s <- sd(x, na.rm=TRUE)
sprintf("%.1f (%.1f)", m, s)
} else {
md <- median(x, na.rm=TRUE); iq <- IQR(x, na.rm=TRUE)
sprintf("%.1f [%.1f]", md, iq)
}
}
stats <- sapply(lvls, function(g) fun_stat(vals[grp==g], p_norm))
nvals <- sapply(lvls, function(g) sum(!is.na(vals[grp==g])))
stat_with_n <- paste0(stats, " [n=", nvals, "]")
return(stat_with_n)
} else {
# For categorical: n (%)
levels_cat <- levels(as.factor(vals))
stats_cat <- sapply(lvls, function(g) {
tot <- sum(grp==g & !is.na(vals))
lv_counts <- sapply(levels_cat, function(lv) sum((vals==lv) & (grp==g), na.rm=TRUE))
lv_perc <- round(100*lv_counts/tot,1)
paste(mapply(function(n, p, l) sprintf("%s: %d (%.1f%%)", l, n, p), lv_counts, lv_perc, levels_cat), collapse=" / ")
})
return(stats_cat)
}
}
cramerV <- function(tab){
chi2 <- suppressWarnings(chisq.test(tab, correct=FALSE)$statistic)
n <- sum(tab)
min_dim <- min(dim(tab)) - 1
sqrt(as.numeric(chi2)/(n*min_dim))
}
get_pvals_es <- function(varlist, groupvar, df){
res <- lapply(varlist, function(v){
vals <- df[[v]]; g <- df[[group_var]]
lvls <- levels(as.factor(g))
non_missing <- !(is.na(vals) | is.na(g))
vals_nm <- vals[non_missing]; g_nm <- g[non_missing]
idx1 <- which(g_nm==lvls[1]); idx2 <- which(g_nm==lvls[2])
n1 <- length(idx1); n2 <- length(idx2)
# Only run if two groups (as in manuscript)
if (length(unique(g_nm)) != 2) return(list(test=NA, pval=NA, effectsize=NA, n1=n1, n2=n2))
if (is.numeric(vals_nm) | is.integer(vals_nm)){
p_norm <- tryCatch(shapiro.test(vals_nm)$p.value, error=function(e) NA)
group1 <- vals_nm[idx1]; group2 <- vals_nm[idx2]
# Effect size always group2-group1
if (!is.na(p_norm) && p_norm > 0.05){
ttest <- t.test(vals_nm ~ g_nm)
es <- tryCatch(effsize::cohen.d(vals_nm, g_nm, hedges.correction=TRUE)$estimate, error=function(e) NA)
return(list(test="Welch t", pval=ttest$p.value, effectsize=es, n1=n1, n2=n2))
} else {
wilcox <- wilcox.test(vals_nm ~ g_nm)
es <- tryCatch(effsize::cohen.d(vals_nm, g_nm, hedges.correction=TRUE)$estimate, error=function(e) NA)
return(list(test="Mann–Whitney", pval=wilcox$p.value, effectsize=es, n1=n1, n2=n2))
}
} else {
tbl <- table(vals_nm, g_nm)
if(any(tbl < 5)) {
test <- "Fisher"
pval <- fisher.test(tbl)$p.value
} else {
test <- "ChiSquare"
pval <- chisq.test(tbl)$p.value
}
es <- tryCatch(cramerV(tbl), error = function(e) NA)
return(list(test=test, pval=pval, effectsize=es, n1=n1, n2=n2))
}
})
names(res) <- varlist
return(res)
}
result_tab1 <- get_pvals_es(vars_table1, group_var, df_baseline)
tab1_journal <- tibble(
Variable = vars_table1,
StableCN = sapply(vars_table1, function(v) get_group_summary(v, df_baseline)[1]),
CNtransitMCI = sapply(vars_table1, function(v) get_group_summary(v, df_baseline)[2]),
N_StableCN = sapply(result_tab1, function(x) x$n1),
N_CNtransitMCI = sapply(result_tab1, function(x) x$n2),
Test = sapply(result_tab1, function(x) x$test),
PValue = sapply(result_tab1, function(x) x$pval),
EffectSize = sapply(result_tab1, function(x) x$effectsize)
)
write.csv(tab1_journal, file.path(output_dir, "table1_journalformat.csv"), row.names=FALSE)
cat("Table 1 exported to", file.path(output_dir, "table1_journalformat.csv"), "\n")
library(dplyr)
library(emmeans)
library(tibble)
output_dir <- "Baseline_Results"
if (!dir.exists(output_dir)) dir.create(output_dir)
df_baseline <- df4 %>%
filter(Change_Type %in% c("StableCN", "CNtransitMCI")) %>%
group_by(USUBJID) %>%
filter(datetest == min(datetest)) %>%
ungroup()
df_baseline$SEX <- as.factor(df_baseline$SEX)
df_baseline$Change_Type <- factor(df_baseline$Change_Type, levels = c("StableCN", "CNtransitMCI")) # đảm bảo thứ tự nhóm
vars_table2 <- c('height','weight','Waistcir','Hipcir','sysbp','diabp','bmi','ac','whr',
'pbcm','pbf','bmr','tbw_ffm','ecw_tcw','PA50_total')
vars_table3 <- c('ECW_ICW_upper','ECW_ICW_lower','Water_Lean_upper','Water_Lean_lower',
'R_upper','R_lower','Xc_upper','Xc_lower','PA_upper','PA_lower',
'R_H_upper','R_H_lower','Xc_H_upper','Xc_H_lower')
group_var <- "Change_Type"
covars <- c("AGE", "SEX", "EDUYR")
units_table2 <- c(height="cm", weight="kg", Waistcir="cm", Hipcir="cm",
sysbp="mmHg", diabp="mmHg", bmi="kg/m2", ac="", whr="", pbcm="%", pbf="%", bmr="kcal",
tbw_ffm="%", ecw_tcw="%", PA50_total="degree")
units_table3 <- c(
ECW_ICW_upper="%", ECW_ICW_lower="%", Water_Lean_upper="%", Water_Lean_lower="%",
R_upper="Ohm", R_lower="Ohm", Xc_upper="Ohm", Xc_lower="Ohm",
PA_upper="degree", PA_lower="degree",
R_H_upper="Ohm", R_H_lower="Ohm", Xc_H_upper="Ohm", Xc_H_lower="Ohm"
)
get_sample_size <- function(df, v, lvl) {
# Đếm số mẫu không missing cho từng nhóm
sum(!is.na(df[[v]]) & df[[group_var]] == lvl)
}
get_ancova_table <- function(varlist, groupvar, covars, df, units=NULL) {
allout <- lapply(varlist, function(v) {
fml <- as.formula(paste(v, "~", groupvar, "+", paste(covars, collapse=" + ")))
model <- lm(fml, data=df, na.action=na.exclude)
emm <- emmeans(model, groupvar)
summary_emm <- summary(emm, level=0.95)
contrasts <- summary(contrast(emm, method="pairwise"), infer=TRUE)
aovm <- tryCatch(anova(model), error=function(e) NULL)
eta2 <- tryCatch({
ss_group <- aovm[groupvar, "Sum Sq"]
ss_total <- sum(aovm[,"Sum Sq"])
ss_group/ss_total
}, error = function(e) NA)
adj_r2 <- tryCatch(summary(model)$adj.r.squared, error=function(e) NA)
# Tên nhóm (đảm bảo đúng thứ tự: StableCN, CNtransitMCI)
g1 <- levels(df[[groupvar]])[1]
g2 <- levels(df[[groupvar]])[2]
n1 <- get_sample_size(df, v, g1)
n2 <- get_sample_size(df, v, g2)
tibble(
Variable = v,
Unit = if (!is.null(units) && !is.na(units[v])) units[v] else "",
N_StableCN = n1,
N_CNtransitMCI = n2,
StableCN_AdjMean_CI = sprintf("%.2f (%.2f, %.2f)", summary_emm$emmean[which(summary_emm[[groupvar]] == g1)],
summary_emm$lower.CL[which(summary_emm[[groupvar]] == g1)],
summary_emm$upper.CL[which(summary_emm[[groupvar]] == g1)]),
CNtransitMCI_AdjMean_CI = sprintf("%.2f (%.2f, %.2f)", summary_emm$emmean[which(summary_emm[[groupvar]] == g2)],
summary_emm$lower.CL[which(summary_emm[[groupvar]] == g2)],
summary_emm$upper.CL[which(summary_emm[[groupvar]] == g2)]),
Diff_CI = sprintf("%.2f (%.2f, %.2f)", contrasts$estimate[1], contrasts$lower.CL[1], contrasts$upper.CL[1]),
SE = round(contrasts$SE[1],2),
PValue = round(contrasts$p.value[1],4),
EtaSq = round(eta2,3),
Adj_R2 = round(adj_r2,3)
)
})
do.call(rbind, allout)
}
# --- Generate and export tables ---
tbl2_journal <- get_ancova_table(vars_table2, group_var, covars, df_baseline, units_table2)
tbl3_journal <- get_ancova_table(vars_table3, group_var, covars, df_baseline, units_table3)
write.csv(tbl2_journal, file.path(output_dir, "table2_journalformat.csv"), row.names=FALSE)
write.csv(tbl3_journal, file.path(output_dir, "table3_journalformat.csv"), row.names=FALSE)
cat("Table 2 & 3 đã xuất ra .csv format journal ở folder:", output_dir, "\n")
