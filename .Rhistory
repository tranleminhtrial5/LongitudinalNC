vars_table2 <- c('height','weight','Waistcir','Hipcir','sysbp','diabp','bmi','ac','whr',
'pbcm','pbf','bmr','tbw_ffm','ecw_tcw','PA50_total')
vars_table3 <- c('ECW_ICW_upper','ECW_ICW_lower','Water_Lean_upper','Water_Lean_lower',
'R_upper','R_lower','Xc_upper','Xc_lower','PA_upper','PA_lower',
'R_H_upper','R_H_lower','Xc_H_upper','Xc_H_lower')
group_var <- "Change_Type"
covars <- c("AGE", "SEX", "EDUYR")
tab1 <- CreateTableOne(vars=vars_table1, strata=group_var, data=df_baseline)
print(tab1, showAllLevels=TRUE, quote=TRUE, noSpaces=TRUE)
get_pvals_es <- function(varlist, groupvar, df){
res <- lapply(varlist, function(v){
vals <- df[[v]]; g <- df[[groupvar]]
non_missing <- !(is.na(vals) | is.na(g))
vals_nm <- vals[non_missing]
g_nm <- g[non_missing]
pval <- NA; effsize <- NA
if (length(unique(g_nm)) != 2) return(list(pval=NA,effsize=NA))
if (is.numeric(vals_nm) | is.integer(vals_nm)){
p_norm <- tryCatch(shapiro.test(vals_nm)$p.value,error=function(e) NA)
if (!is.na(p_norm) && p_norm > 0.05){
ttest <- t.test(vals_nm ~ g_nm)
pval <- ttest$p.value
effsize <- effsize::cohen.d(vals_nm, g_nm)$estimate
}else{
wilcox <- wilcox.test(vals_nm ~ g_nm)
pval <- wilcox$p.value
effsize <- effsize::cohen.d(vals_nm, g_nm, hedges.correction=TRUE)$estimate
}
}else{
tbl <- table(vals_nm, g_nm)
pval <- if(any(tbl < 5)) fisher.test(tbl)$p.value else chisq.test(tbl)$p.value
effsize <- NA
}
return(list(pval=pval,effsize=effsize))
})
names(res) <- varlist
return(res)
}
result_table1 <- get_pvals_es(vars_table1, group_var, df_baseline)
print(result_table1)
get_group_coef <- function(res, group_var, df) {
levs <- levels(df[[group_var]])
target_lev <- levs[2]
target_name <- grep(target_lev, rownames(coef(res)), value=TRUE)
if(length(target_name) == 1) {
pval <- coef(res)[target_name, "Pr(>|t|)"]
est <- coef(res)[target_name, "Estimate"]
} else {
pval <- NA
est <- NA
}
return(list(pval=pval, estimate=est))
}
ancova_tab2 <- lapply(vars_table2, function(v){
formula <- as.formula(paste(v, "~", group_var, "+ AGE + SEX + EDUYR"))
model <- lm(formula, data=df_baseline, na.action=na.exclude)
res <- summary(model)
grp <- get_group_coef(res, group_var, df_baseline)
return(list(pval=grp$pval, estimate=grp$estimate, model=res))
})
names(ancova_tab2) <- vars_table2
ancova_tab3 <- lapply(vars_table3, function(v){
formula <- as.formula(paste(v, "~", group_var, "+ AGE + SEX + EDUYR"))
model <- lm(formula, data=df_baseline, na.action=na.exclude)
res <- summary(model)
grp <- get_group_coef(res, group_var, df_baseline)
return(list(pval=grp$pval, estimate=grp$estimate, model=res))
})
names(ancova_tab3) <- vars_table3
print_ancova <- function(res_list, units = NULL) {
for (v in names(res_list)) {
est <- res_list[[v]]$estimate
pval <- res_list[[v]]$pval
u <- if(!is.null(units) && !is.na(units[v])) units[v] else ""
cat(sprintf("%-25s Estimate: %8.3f %-5s | p-value: %.4f\n", v, est, u, pval))
}
}
units_table2 <- c(height = "cm", weight = "kg", BMI = "", whr = "", pbcm = "%", pbf = "%", bmr = "kcal", ecw_tcw = "%", tbw_ffm = "%", PA50_total = "degree")
units_table3 <- c(
ECW_ICW_upper = "%", ECW_ICW_lower = "%", Water_Lean_upper = "%", Water_Lean_lower = "%",
R_upper = "Ω", R_lower = "Ω", Xc_upper = "Ω", Xc_lower = "Ω", PA_upper = "degree", PA_lower = "degree",
R_H_upper = "Ω", R_H_lower = "Ω", Xc_H_upper = "Ω", Xc_H_lower = "Ω"
)
cat("\n===== Table 2: ANCOVA Results =====\n")
print_ancova(ancova_tab2, units_table2)
cat("\n===== Table 3: ANCOVA Results =====\n")
print_ancova(ancova_tab3, units_table3)
ggplot(df_baseline, aes(x=Change_Type, y=R_lower, fill=Change_Type)) +
geom_violin(trim=FALSE) +
geom_boxplot(width=0.1, fill="white") +
labs(title="R_lower by Group", y="R_lower") +
theme_minimal()
#write.csv(print(tab1, quote = TRUE, noSpaces = TRUE), "table1_baseline.csv")
tbl2_results <- sapply(names(ancova_tab2), function(var) c(Estimate = ancova_tab2[[var]]$estimate, Pvalue = ancova_tab2[[var]]$pval))
#write.csv(tbl2_results, "table2_ancova.csv")
tbl3_results <- sapply(names(ancova_tab3), function(var) c(Estimate = ancova_tab3[[var]]$estimate, Pvalue = ancova_tab3[[var]]$pval))
#write.csv(tbl3_results, "table3_ancova.csv")
bia_vars <- c("MMSE","SNSB_attention","SNSB_language", "SNSB_visuospatial", "SNSB_memory", "SNSB_frontal","bmi","whr","pbcm","pbf","bmr","ecw_tcw","tbw_ffm","PA50_total",
"ECW_ICW_upper","ECW_ICW_lower","Water_Lean_upper","Water_Lean_lower",
"R_upper","R_lower","Xc_upper","Xc_lower",
"PA_upper","PA_lower","R_H_upper","R_H_lower","Xc_H_upper","Xc_H_lower")
df_long.analysis <- df4 %>%
filter(Change_Type %in% c("StableCN", "CNtransitMCI"))
spaghetti_plots <- lapply(bia_vars, function(var) {
ggplot(df_long.analysis, aes(x = elapsed_years, y = .data[[var]], group = USUBJID, color = Change_Type)) +
geom_line(alpha = 0.35) +
geom_smooth(aes(group = Change_Type, color = Change_Type), method = "loess", se = FALSE, linewidth = 1.5) +
labs(title = paste("Spaghetti Plot:", var), y = var, x = "Years") +
theme_minimal()
})
do.call(cowplot::plot_grid, c(spaghetti_plots[1:6], ncol = 2))
do.call(cowplot::plot_grid, c(spaghetti_plots[1:9], ncol = 3))
print(spaghetti_plots[[1]])
#for(i in seq_along(bia_vars)) {
#  ggsave(filename = paste0("spaghetti_", bia_vars[i], ".png"),
#         plot = spaghetti_plots[[i]], width = 6, height = 4)
#}
# --- Libraries ---
library(lmerTest)
library(emmeans)
library(dplyr)
library(tibble)
library(ggeffects)
library(forcats)
df_long.analysis$Change_Type <- as.factor(df_long.analysis$Change_Type)
df_long.analysis$Change_Type <- fct_recode(
df_long.analysis$Change_Type,
StableCN = "StableCN",
CNtransitMCI = "CNtransitMCI"
)
print(levels(df_long.analysis$Change_Type))
print(table(df_long.analysis$Change_Type, useNA = "always"))
referencegroup <- "StableCN"
comparisongroups <- c("CNtransitMCI")
# --- Core Analysis Function: LME + LRT + Wald ---
analyze_longitudinal_trends_LRT <- function(
data, response, xvar = "elapsed_years", groupvar = "Change_Type",
covariates = c("AGE", "SEX", "EDUYR"), subjectid = "USUBJID",
referencegroup, comparisongroups
) {
# Validate group levels first
levels_grp <- levels(as.factor(data[[groupvar]]))
if (!referencegroup %in% levels_grp) stop(paste("Reference group", referencegroup, "not found in levels"))
if (any(!comparisongroups %in% levels_grp)) stop(paste("Comparison group(s)", paste(comparisongroups[!comparisongroups %in% levels_grp], collapse=", "), "not found in levels"))
# Set reference level for modeling
data[[groupvar]] <- as.factor(data[[groupvar]])
data[[groupvar]] <- relevel(data[[groupvar]], ref = referencegroup)
# Model formulas
formula_full <- as.formula(
paste0(response, " ~ ", xvar, "*", groupvar, " + ", paste(covariates, collapse = " + "),
" + (1 + ", xvar, "|", subjectid, ")")
)
formula_noint <- as.formula(
paste0(response, " ~ ", xvar, " + ", groupvar, " + ", paste(covariates, collapse = " + "),
" + (1 + ", xvar, "|", subjectid, ")")
)
# Check for all NA or missing column
if (!response %in% names(data) || all(is.na(data[[response]]))) {
warning(paste("Skipping", response, "because data is missing or all NA"))
return(list(modelsummary = tibble(Outcome = response, Comparison = paste(comparisongroups, "vs", referencegroup),
Slope_Ref = NA, Slope_Comp = NA, Slope_Diff = NA,
Slope_SE = NA, Slope_Lower = NA, Slope_Upper = NA,
Slope_p = NA, Cohen_d = NA, Wald_p = NA,
LRT_p = NA, LRT_chi = NA, LRT_df = NA, ResidualSD = NA)))
}
# Fit models
mod_full <- tryCatch(lmerTest::lmer(formula_full, data = data, REML=FALSE), error = function(e) NA)
mod_noint <- tryCatch(lmerTest::lmer(formula_noint, data = data, REML=FALSE), error = function(e) NA)
if (any(is.na(c(mod_full, mod_noint)))) {
warning(paste("Model fit failed for", response))
return(list(modelsummary = tibble(Outcome = response, Comparison = paste(comparisongroups, "vs", referencegroup),
Slope_Ref = NA, Slope_Comp = NA, Slope_Diff = NA,
Slope_SE = NA, Slope_Lower = NA, Slope_Upper = NA,
Slope_p = NA, Cohen_d = NA, Wald_p = NA,
LRT_p = NA, LRT_chi = NA, LRT_df = NA, ResidualSD = NA)))
}
# LRT p-value
lrt <- anova(mod_noint, mod_full)
lrt_p <- lrt$`Pr(>Chisq)`[2]
lrt_chi <- lrt$Chisq[2]
lrt_df <- lrt$Df[2]
# Wald p-value
coefmat <- coef(summary(mod_full))
interaction_row <- grep(paste0(xvar, ":", groupvar), rownames(coefmat), value = TRUE)
wald_p <- if(length(interaction_row) > 0) coefmat[interaction_row, "Pr(>|t|)"] else NA_real_
# Slope extraction
emt <- emmeans::emtrends(mod_full, specs = groupvar, var = xvar)
sum_emt <- summary(emt, infer = TRUE)
slope_tests <- sum_emt %>% dplyr::rename(slope = !!paste0(xvar, ".trend"), group = !!groupvar)
refstats <- slope_tests %>% filter(group == referencegroup)
compstats <- lapply(comparisongroups, function(g) slope_tests %>% filter(group == g))
names(compstats) <- comparisongroups
# Slope difference & 95% CI
contrast_out <- emmeans::contrast(emt, method = "revpairwise")
sum_contrast <- summary(contrast_out, infer = TRUE)
# Effect size
sigma_resid <- suppressWarnings(sigma(mod_full))
cohensd <- sapply(comparisongroups, function(g) {
comp <- compstats[[g]]$slope
ref <- refstats$slope
if (length(comp)==0 || length(ref)==0 || is.na(sigma_resid)) {
NA
} else {
abs((comp - ref)/sigma_resid)
}
})
# Output summary: robust to missing pairwise
meta_rows <- lapply(comparisongroups, function(g) {
contrastA <- paste(referencegroup, g, sep = " - ")
contrastB <- paste(g, referencegroup, sep = " - ")
idx <- which(sum_contrast$contrast %in% c(contrastA, contrastB))
if(length(idx)==1 && nrow(refstats)==1 && nrow(compstats[[g]])==1) {
# If the contrast is "g - referencegroup", flip sign
sign_mult <- if (sum_contrast$contrast[idx] == contrastA) 1 else -1
tibble(
Outcome = response,
Comparison = paste(g, "vs", referencegroup),
Slope_Ref = round(refstats$slope, 4),
Slope_Comp = round(compstats[[g]]$slope, 4),
Slope_Diff = round(sign_mult * sum_contrast$estimate[idx], 4),
Slope_SE = round(sum_contrast$SE[idx], 4),
Slope_Lower = round(sign_mult * sum_contrast$lower.CL[idx], 4),
Slope_Upper = round(sign_mult * sum_contrast$upper.CL[idx], 4),
Slope_p = round(sum_contrast$p.value[idx], 5),
Cohen_d = round(cohensd[g], 4),
Wald_p = round(wald_p, 5),
LRT_p = round(lrt_p, 5),
LRT_chi = round(lrt_chi, 3),
LRT_df = lrt_df,
ResidualSD = round(sigma_resid, 3)
)
} else {
tibble(
Outcome = response,
Comparison = paste(g, "vs", referencegroup),
Slope_Ref = NA, Slope_Comp = NA, Slope_Diff = NA,
Slope_SE = NA, Slope_Lower = NA, Slope_Upper = NA,
Slope_p = NA, Cohen_d = NA, Wald_p = NA,
LRT_p = NA, LRT_chi = NA, LRT_df = NA, ResidualSD = NA
)
}
})
modelsummary <- bind_rows(meta_rows)
list(
modelsummary = modelsummary,
mod_full = mod_full,
mod_noint = mod_noint,
lrt = lrt,
wald_p = wald_p,
slopes = sum_emt,
contrast = sum_contrast,
cohensd = cohensd
)
}
# --- List of Markers ---
biavars <- c(
"MMSE", "SNSB_attention", "SNSB_language", "SNSB_visuospatial", "SNSB_memory", "SNSB_frontal",
"bmi", "whr", "pbcm", "pbf", "bmr", "ecw_tcw", "tbw_ffm", "PA50_total",
"ECW_ICW_upper", "ECW_ICW_lower", "Water_Lean_upper", "Water_Lean_lower",
"R_upper", "R_lower", "Xc_upper", "Xc_lower", "PA_upper", "PA_lower",
"R_H_upper", "R_H_lower", "Xc_H_upper", "Xc_H_lower"
)
# --- Batch Analysis ---
results <- lapply(biavars, function(var) {
print(paste("Analyzing:", var))
analyze_longitudinal_trends_LRT(
data = df_long.analysis,
response = var,
groupvar = "Change_Type",
referencegroup = referencegroup,
comparisongroups = comparisongroups
)
})
modelsummarylist <- lapply(results, function(x) x$modelsummary)
allsummaries <- bind_rows(modelsummarylist, .id = "Biomarker")
write.csv(allsummaries, "Bioimpedance_LME_LRT_summary.csv", row.names = FALSE)
# --- Libraries ---
library(lmerTest)
library(emmeans)
library(dplyr)
library(tibble)
library(ggeffects)
library(forcats)
df_long.analysis$Change_Type <- as.factor(df_long.analysis$Change_Type)
df_long.analysis$Change_Type <- fct_recode(
df_long.analysis$Change_Type,
StableCN = "StableCN",
CNtransitMCI = "CNtransitMCI"
)
print(levels(df_long.analysis$Change_Type))
print(table(df_long.analysis$Change_Type, useNA = "always"))
referencegroup <- "StableCN"
comparisongroups <- c("CNtransitMCI")
# --- Core Analysis Function: LME + LRT + Wald ---
analyze_longitudinal_trends_LRT <- function(
data, response, xvar = "elapsed_years", groupvar = "Change_Type",
covariates = c("AGE", "SEX", "EDUYR"), subjectid = "USUBJID",
referencegroup, comparisongroups
) {
# Validate group levels first
levels_grp <- levels(as.factor(data[[groupvar]]))
if (!referencegroup %in% levels_grp) stop(paste("Reference group", referencegroup, "not found in levels"))
if (any(!comparisongroups %in% levels_grp)) stop(paste("Comparison group(s)", paste(comparisongroups[!comparisongroups %in% levels_grp], collapse=", "), "not found in levels"))
# Set reference level for modeling
data[[groupvar]] <- as.factor(data[[groupvar]])
data[[groupvar]] <- relevel(data[[groupvar]], ref = referencegroup)
# Model formulas
formula_full <- as.formula(
paste0(response, " ~ ", xvar, "*", groupvar, " + ", paste(covariates, collapse = " + "),
" + (1 + ", xvar, "|", subjectid, ")")
)
formula_noint <- as.formula(
paste0(response, " ~ ", xvar, " + ", groupvar, " + ", paste(covariates, collapse = " + "),
" + (1 + ", xvar, "|", subjectid, ")")
)
# Check for all NA or missing column
if (!response %in% names(data) || all(is.na(data[[response]]))) {
warning(paste("Skipping", response, "because data is missing or all NA"))
return(list(modelsummary = tibble(Outcome = response, Comparison = paste(comparisongroups, "vs", referencegroup),
Slope_Ref = NA, Slope_Comp = NA, Slope_Diff = NA,
Slope_SE = NA, Slope_Lower = NA, Slope_Upper = NA,
Slope_p = NA, Cohen_d = NA, Wald_p = NA,
LRT_p = NA, LRT_chi = NA, LRT_df = NA, ResidualSD = NA)))
}
# Fit models
mod_full <- tryCatch(lmerTest::lmer(formula_full, data = data, REML=FALSE), error = function(e) NA)
mod_noint <- tryCatch(lmerTest::lmer(formula_noint, data = data, REML=FALSE), error = function(e) NA)
if (any(is.na(c(mod_full, mod_noint)))) {
warning(paste("Model fit failed for", response))
return(list(modelsummary = tibble(Outcome = response, Comparison = paste(comparisongroups, "vs", referencegroup),
Slope_Ref = NA, Slope_Comp = NA, Slope_Diff = NA,
Slope_SE = NA, Slope_Lower = NA, Slope_Upper = NA,
Slope_p = NA, Cohen_d = NA, Wald_p = NA,
LRT_p = NA, LRT_chi = NA, LRT_df = NA, ResidualSD = NA)))
}
# LRT p-value
lrt <- anova(mod_noint, mod_full)
lrt_p <- lrt$`Pr(>Chisq)`[2]
lrt_chi <- lrt$Chisq[2]
lrt_df <- lrt$Df[2]
# Wald p-value
coefmat <- coef(summary(mod_full))
interaction_row <- grep(paste0(xvar, ":", groupvar), rownames(coefmat), value = TRUE)
wald_p <- if(length(interaction_row) > 0) coefmat[interaction_row, "Pr(>|t|)"] else NA_real_
# Slope extraction
emt <- emmeans::emtrends(mod_full, specs = groupvar, var = xvar)
sum_emt <- summary(emt, infer = TRUE)
slope_tests <- sum_emt %>% dplyr::rename(slope = !!paste0(xvar, ".trend"), group = !!groupvar)
refstats <- slope_tests %>% filter(group == referencegroup)
compstats <- lapply(comparisongroups, function(g) slope_tests %>% filter(group == g))
names(compstats) <- comparisongroups
# Slope difference & 95% CI
contrast_out <- emmeans::contrast(emt, method = "revpairwise")
sum_contrast <- summary(contrast_out, infer = TRUE)
# Effect size
sigma_resid <- suppressWarnings(sigma(mod_full))
cohensd <- sapply(comparisongroups, function(g) {
comp <- compstats[[g]]$slope
ref <- refstats$slope
if (length(comp)==0 || length(ref)==0 || is.na(sigma_resid)) {
NA
} else {
abs((comp - ref)/sigma_resid)
}
})
# Output summary: robust to missing pairwise
meta_rows <- lapply(comparisongroups, function(g) {
contrastA <- paste(referencegroup, g, sep = " - ")
contrastB <- paste(g, referencegroup, sep = " - ")
idx <- which(sum_contrast$contrast %in% c(contrastA, contrastB))
if(length(idx)==1 && nrow(refstats)==1 && nrow(compstats[[g]])==1) {
# If the contrast is "g - referencegroup", flip sign
sign_mult <- if (sum_contrast$contrast[idx] == contrastA) 1 else -1
tibble(
Outcome = response,
Comparison = paste(g, "vs", referencegroup),
Slope_Ref = round(refstats$slope, 4),
Slope_Comp = round(compstats[[g]]$slope, 4),
Slope_Diff = round(sign_mult * sum_contrast$estimate[idx], 4),
Slope_SE = round(sum_contrast$SE[idx], 4),
Slope_Lower = round(sign_mult * sum_contrast$lower.CL[idx], 4),
Slope_Upper = round(sign_mult * sum_contrast$upper.CL[idx], 4),
Slope_p = round(sum_contrast$p.value[idx], 5),
Cohen_d = round(cohensd[g], 4),
Wald_p = round(wald_p, 5),
LRT_p = round(lrt_p, 5),
LRT_chi = round(lrt_chi, 3),
LRT_df = lrt_df,
ResidualSD = round(sigma_resid, 3)
)
} else {
tibble(
Outcome = response,
Comparison = paste(g, "vs", referencegroup),
Slope_Ref = NA, Slope_Comp = NA, Slope_Diff = NA,
Slope_SE = NA, Slope_Lower = NA, Slope_Upper = NA,
Slope_p = NA, Cohen_d = NA, Wald_p = NA,
LRT_p = NA, LRT_chi = NA, LRT_df = NA, ResidualSD = NA
)
}
})
modelsummary <- bind_rows(meta_rows)
list(
modelsummary = modelsummary,
mod_full = mod_full,
mod_noint = mod_noint,
lrt = lrt,
wald_p = wald_p,
slopes = sum_emt,
contrast = sum_contrast,
cohensd = cohensd
)
}
# --- List of Markers ---
biavars <- c(
"MMSE", "SNSB_attention", "SNSB_language", "SNSB_visuospatial", "SNSB_memory", "SNSB_frontal",
"bmi", "whr", "pbcm", "pbf", "bmr", "ecw_tcw", "tbw_ffm", "PA50_total",
"ECW_ICW_upper", "ECW_ICW_lower", "Water_Lean_upper", "Water_Lean_lower",
"R_upper", "R_lower", "Xc_upper", "Xc_lower", "PA_upper", "PA_lower",
"R_H_upper", "R_H_lower", "Xc_H_upper", "Xc_H_lower"
)
# --- Batch Analysis ---
results <- lapply(biavars, function(var) {
print(paste("Analyzing:", var))
analyze_longitudinal_trends_LRT(
data = df_long.analysis,
response = var,
groupvar = "Change_Type",
referencegroup = referencegroup,
comparisongroups = comparisongroups
)
})
modelsummarylist <- lapply(results, function(x) x$modelsummary)
allsummaries <- bind_rows(modelsummarylist, .id = "Biomarker")
write.csv(allsummaries, "Bioimpedance_LME_LRT_summary.csv", row.names = FALSE)
print("Check complete: Output summary table written!")
# --- Batch Plot Generation (Wald + LRT) ---
output_dir_wald <- "Bioimpedance_Trajectory_WaldPlots"
output_dir_lrt <- "Bioimpedance_Trajectory_LRTPlots"
dir.create(output_dir_wald, showWarnings = FALSE)
dir.create(output_dir_lrt, showWarnings = FALSE)
plots_wald <- lapply(biavars, function(var)
plot_lmer_model_with_interaction_p(
data = df_long.analysis,
response = var,
colors = colors.legend
)
)
plots_lrt <- lapply(biavars, function(var)
plot_lmer_interaction_with_p(
data = df_long.analysis,
response = var,
colors = colors.legend,
show.legend = FALSE
)
)
for (i in seq_along(biavars)) {
pw <- plots_wald[[i]]
pl <- plots_lrt[[i]]
if (inherits(pw, "ggplot")) {
ggsave(
filename = file.path(output_dir_wald, paste0(biavars[i], "_waldplot.png")),
plot = pw, width = 7, height = 5, dpi = 300
)
}
if (inherits(pl, "ggplot")) {
ggsave(
filename = file.path(output_dir_lrt, paste0(biavars[i], "_lrtplot.png")),
plot = pl, width = 7, height = 5, dpi = 300
)
}
}
library(performance)
if (!dir.exists("Diagnostics")) dir.create("Diagnostics")
safe_var_extract <- function(vardf, grpval, var1val, var2val) {
idx <- which(vardf$grp==grpval & vardf$var1==var1val & vardf$var2==var2val)
if(length(idx)==1 && !is.na(vardf$vcov[idx])) vardf$vcov[idx] else NA_real_
}
safe_r2 <- function(model) {
out <- tryCatch(
suppressWarnings(performance::r2(model)),
error = function(e) list(R2_marginal=NA_real_, R2_conditional=NA_real_)
)
list(marginal=out$R2_marginal, conditional=out$R2_conditional)
}
diagnostics_list <- lapply(seq_along(biavars), function(i) {
var <- biavars[i]
m <- results[[i]]$mod_full
png(filename = sprintf("Diagnostics/%s_QQplot.png", var), width = 700, height = 700)
qqnorm(residuals(m)); qqline(residuals(m)); dev.off()
png(filename = sprintf("Diagnostics/%s_ResVsFitted.png", var), width = 700, height = 700)
plot(fitted(m), residuals(m), main = paste(var, "Fitted vs Residuals"),
xlab = "Fitted Values", ylab = "Residuals"); abline(h = 0, lty = 2); dev.off()
aic <- tryCatch(AIC(m), error=function(e) NA_real_)
bic <- tryCatch(BIC(m), error=function(e) NA_real_)
r2 <- safe_r2(m)
ranef_var <- tryCatch(as.data.frame(VarCorr(m)), error=function(e) data.frame())
rand_intercept <- if(nrow(ranef_var)>0) safe_var_extract(ranef_var,"USUBJID","","") else NA_real_
rand_slope <- if(nrow(ranef_var)>0) safe_var_extract(ranef_var,"USUBJID","elapsed_years","") else NA_real_
conv_warn <- if (!is.null(m@optinfo$conv$lme4$messages)) paste(m@optinfo$conv$lme4$messages, collapse="; ") else NA
singular_flag <- if (isSingular(m, tol=1e-4)) "singular" else NA
data.frame(Biomarker = var,
AIC = aic, BIC = bic,
Marginal_R2 = r2$marginal,
Conditional_R2 = r2$conditional,
RandomInterceptVar = rand_intercept,
RandomSlopeVar = rand_slope,
ConvergenceWarning = conv_warn,
SingularFit = singular_flag)
})
diagnostics_df <- do.call(rbind, diagnostics_list)
write.csv(diagnostics_df, "Diagnostics/Bioimpedance_LME_diagnostics.csv", row.names = FALSE)
