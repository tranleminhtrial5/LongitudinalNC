label_vars <- c("COGNITIVESTAT", "diagnosis", "SEX", "ApoeE4")
df0[label_vars] <- lapply(df0[label_vars], label_clean)
# Chuẩn hóa diagnosis mapping
# Thêm tất cả khả năng spelling/case về các nhóm chính
df0$diagnosis_std <- dplyr::case_when(
df0$COGNITIVESTAT %in% c("cn","smi")         ~ "CN",
df0$COGNITIVESTAT %in% c("amci","namci")     ~ "MCI",
df0$COGNITIVESTAT == "ad"                    ~ "AD",
TRUE                                         ~ NA_character_
)
# Nếu cần vẫn giữ diagnosis cũ để check sau này
df0$diagnosis_raw <- df0$diagnosis
# Tiếp tục các xử lý khác dựa trên df0$diagnosis_std thay vì diagnosis gốc
# ----------- (e) Flag outlier giữ dataset đầy đủ và dataset sạch -----------
# Gán outlier flag (sử dụng giống đoạn script bạn đang làm, nhưng chỉ gắn cờ thay vì filter loại khỏi dataset):
vars_check_outlier <- c(
"AGE","bmi", "whr", "pbcm", "pbf", "bmr", "icw", "ecw", "tbw", "protein", "smm", "amc",
"R_upper", "R_lower", "Xc_upper", "Xc_lower", "PA_upper", "PA_lower",
"SW_upper", "SW_lower", "SL_upper", "SL_lower","sw_tr", "sl_tr",
"R5_upper", "R5_lower",
"Xc5_upper", "Xc5_lower", "z1_upper", "z1_lower", "z5_upper", "z5_lower"
)
vars_exist <- vars_check_outlier[vars_check_outlier %in% names(df)]
zscore_func <- function(x) (x - mean(x, na.rm=TRUE)) / sd(x, na.rm=TRUE)
df <- df %>%
mutate(across(all_of(vars_exist), zscore_func, .names = "{.col}_z"))
# Flag outlier
df <- df %>%
mutate(outlier_extreme = ifelse(rowSums(across(ends_with("_z"), ~abs(.) > 3), na.rm = TRUE) > 0, 1, 0)) # 1: outlier, 0: clean
# Dataframe đầy đủ (có flag)
df_full <- df
# Dataframe đã loại outlier
df_clean <- df_full %>% filter(outlier_extreme == 0)
# Lưu 2 version:
write.csv(df_full, "Chosun5y_BIApreprocess_full_with_outlier_flag.csv", row.names=FALSE)
write.csv(df_clean, "Chosun5y_BIApreprocess_clean.csv", row.names=FALSE)
# ---------- Báo cáo tổng hợp/chất lượng mẫu ----------
cat("TỔNG HỢP SỐ LƯỢNG CASE:\n")
cat("Tổng số subject (full):", length(unique(df_full$USUBJID)), "\n")
cat("Tổng số subject (clean):", length(unique(df_clean$USUBJID)), "\n")
cat("Số đo trung bình mỗi subject (full):", round(nrow(df_full)/length(unique(df_full$USUBJID)),2), "\n")
cat("Số đo trung bình mỗi subject (clean):", round(nrow(df_clean)/length(unique(df_clean$USUBJID)),2), "\n")
cat("Tỷ lệ còn missing trên từng biến chính (full):\n")
vars_main <- c("MMSE","SNSB_attention","SNSB_language","bmi","whr","PA50_total")
print(sapply(df_full[vars_main], function(x) sum(is.na(x))/length(x)*100))
cat("Tỷ lệ còn missing trên từng biến chính (clean):\n")
print(sapply(df_clean[vars_main], function(x) sum(is.na(x))/length(x)*100))
# ---------- Xuất danh sách outlier detail và biến thiếu ----------
# file outlier
outlier_rows <- df_full %>% filter(outlier_extreme == 1)
outlier_info <- outlier_rows %>%
rowwise() %>%
mutate(
outlier_vars = paste(
vars_exist[unlist(across(all_of(paste0(vars_exist, "_z")), ~abs(.) > 3))],
collapse = ", "
),
max_zscore = max(unlist(across(ends_with("_z"))), na.rm = TRUE)
) %>%
ungroup()
write.csv(outlier_info, "outlier_cases_detail_LOG.csv", row.names=FALSE)
# file missing
missing_report_nonzero <- sapply(df_full, function(x) sum(is.na(x)))
missing_report_nonzero <- data.frame(Variable=names(missing_report_nonzero), Missing_Count=missing_report_nonzero)
missing_report_nonzero <- missing_report_nonzero %>% dplyr::filter(Missing_Count > 0)
write.csv(missing_report_nonzero, "missing_cases_report_LOG.csv", row.names=FALSE)
df <- read.csv("Chosun5y_BIApreprocess_clean.csv", stringsAsFactors = FALSE)
remove_list <- c("E_237", "F_242", "a_531", "E_391", "G_31", "F_385", "a_281", "G_71", "F_333") #CNtransitMCI 9962 "K_368" , 5971 "G_71"
#StableCN 11458 "F_333" , 10014 "E_346", 10851 "F_264"
df <- df %>% filter(!(k_no %in% remove_list))
df <- df %>%
mutate(datetest = as.Date(datetest, format = "%m/%d/%Y"))
df2 <- df %>%
group_by(USUBJID) %>%
filter(n() >= 2) %>%
ungroup()
df2 <- df2 %>%
arrange(USUBJID, datetest)
df3 <- df2 %>%
group_by(USUBJID) %>%
mutate(
Initial_Status = first(diagnosis),
Final_Status = last(diagnosis),
Transition     = paste(Initial_Status, "-", Final_Status),
Change_Type    = case_when(
Initial_Status == "CN"  & Final_Status == "CN"  ~ "StableCN",
Initial_Status == "CN"  & Final_Status == "MCI" ~ "CNtransitMCI",
Initial_Status == "MCI" & Final_Status == "CN"  ~ "MCItransitCN",
Initial_Status == "MCI" & Final_Status == "MCI" ~ "StableMCI",
Initial_Status == "MCI" & Final_Status == "AD"  ~ "MCItransitAD",
Initial_Status == "CN"  & Final_Status == "AD"  ~ "CNtransitAD",
Initial_Status == "AD"  & Final_Status == "MCI" ~ "ADtransitMCI",
Initial_Status == "AD"  & Final_Status == "CN"  ~ "ADtransitCN",
Initial_Status == "AD"  & Final_Status == "AD"  ~ "StableAD",
TRUE ~ NA_character_
),
visit_count = n(),
baseline_date = first(datetest),
elapsed_years = as.numeric(difftime(datetest, baseline_date, units = "days")) / 365.25,
elapsed_years_First_to_Last = as.numeric(difftime(last(datetest), first(datetest), units = "days")) / 365.25
) %>%
ungroup()
df4 <- df3 %>%
filter(elapsed_years_First_to_Last >= 0.916666666)
#write.csv(df4, "df4.csv",row.names = FALSE)
group_counts <- df4 %>%
group_by(Transition, Change_Type) %>%
summarise(count = n()) %>%
mutate(percentage = count / sum(count) * 100)
print(head(df4))
print(group_counts)
# Unique participant-level summary for each Transition and Change_Type group
participant_group_summary <- df4 %>%
group_by(USUBJID) %>%
summarise(
Transition = first(Transition),
Change_Type = first(Change_Type)
) %>%
group_by(Transition, Change_Type) %>%
summarise(
n_participants = n(),
participants = paste(USUBJID, collapse = ", ")
) %>%
ungroup()
print(participant_group_summary)
# ---- Libraries ----
library(dplyr)
library(tableone)
library(effsize)
library(DescTools) # for Cramér's V and CI
output_dir <- "Baseline_Results"
if (!dir.exists(output_dir)) dir.create(output_dir)
### --- Data Preparation: get baseline per subject ---
df_baseline <- df4 %>%
filter(Change_Type %in% c("StableCN", "CNtransitMCI")) %>%
group_by(USUBJID) %>%
filter(datetest == min(datetest)) %>%
ungroup()
df_baseline$SEX <- as.factor(df_baseline$SEX)
df_baseline$Change_Type <- factor(df_baseline$Change_Type, levels = c("StableCN", "CNtransitMCI"))
group_var <- "Change_Type"
# ---- Table 1: Demographics & Cognition ----
vars_table1 <- c('SEX','AGE','EDUYR','gds','kdsq','visit_count','MMSE',
'SNSB_attention','SNSB_language','SNSB_visuospatial',
'SNSB_memory','SNSB_frontal')
tab1 <- CreateTableOne(vars = vars_table1, strata = group_var, data = df_baseline, test = FALSE)
get_missing_pct <- function(x, g) {
res <- tapply(is.na(x), g, mean)
res[is.na(res)] <- 0
res * 100
}
table1stats <- lapply(vars_table1, function(v) {
x <- df_baseline[[v]]
g <- df_baseline[[group_var]]
miss_pct <- get_missing_pct(x, g)
if (length(unique(g)) != 2) return(data.frame(
Variable = v, Type = NA, Pvalue = NA, SMD = NA, SMD_L = NA, SMD_U = NA, EffectSize = NA,
Miss_StableCN = NA, Miss_CNtransitMCI = NA))
if (is.factor(x) | is.character(x)) {
tbl <- table(x, g)
use_fisher <- any(tbl < 5)
pval <- if (use_fisher) fisher.test(tbl)$p.value else chisq.test(tbl)$p.value
# Cramér's V or Cohen's h for binary
es <- tryCatch({
if (nlevels(as.factor(x))==2) {
counts <- table(x, g)
p1 <- prop.table(counts,2)[1,1]
p2 <- prop.table(counts,2)[1,2]
2*abs(asin(sqrt(p1))-asin(sqrt(p2)))
} else {
DescTools::CramerV(tbl, ci = FALSE)
}
}, error=function(e) NA)
return(data.frame(
Variable = v, Type = "cat", Pvalue = pval, SMD = NA, SMD_L = NA, SMD_U = NA, EffectSize = round(es, 3),
Miss_StableCN = round(miss_pct["StableCN"], 2), Miss_CNtransitMCI = round(miss_pct["CNtransitMCI"],2)
))
}
# For numeric variables, Cohen's d (with 95% CI)
is_norm <- tryCatch((shapiro.test(na.omit(x))$p.value > 0.05), error=function(e) FALSE)
test_result <- if (is_norm) t.test(x ~ g) else wilcox.test(x ~ g)
cd <- effsize::cohen.d(x, g, hedges.correction = TRUE, conf.level = 0.95)
return(data.frame(
Variable = v, Type = "num", Pvalue = test_result$p.value, SMD = cd$estimate, SMD_L = cd$conf.int[1], SMD_U = cd$conf.int[2], EffectSize = cd$estimate,
Miss_StableCN = round(miss_pct["StableCN"],2), Miss_CNtransitMCI = round(miss_pct["CNtransitMCI"],2)))
})
df_table1stats <- bind_rows(table1stats)
# Export Table 1
write.csv(print(tab1, quote = TRUE, noSpaces = TRUE), file.path(output_dir,"table1_baseline.csv"))
write.csv(df_table1stats, file.path(output_dir, "table1_baseline_stats_full.csv"), row.names = FALSE)
cat("Table 1 exported as .csv files in", output_dir, "\n")
# ---- Table 2: Anthropometry & Body Composition (Adjusted) ----
vars_table2 <- c('height','weight','Waistcir','Hipcir','bmi','ac','whr',
'pbcm','pbf','bmr','tbw_ffm','ecw_tbw','PA50_total')
covars <- c("AGE", "SEX", "EDUYR")
units_table2 <- c(height = "cm", weight = "kg", Waistcir = "cm", Hipcir = "cm", sysbp = "mmHg", diabp = "mmHg",
bmi = "kg/m2", ac = "", whr = "", pbcm = "%", pbf = "%", bmr = "kcal", tbw_ffm = "%", ecw_tbw = "%", PA50_total = "degree")
get_sample_size <- function(df, v, lvl) sum(!is.na(df[[v]]) & df[[group_var]] == lvl)
get_missing_pct_tbl <- function(df, v, lvl) mean(is.na(df[[v]]) & df[[group_var]] == lvl) * 100
get_ancova_table <- function(varlist, groupvar, covars, df, units = NULL) {
lapply(varlist, function(v) {
fml <- as.formula(paste(v, "~", groupvar, "+", paste(covars, collapse = " + ")))
model <- lm(fml, data = df, na.action = na.exclude)
emm <- emmeans(model, groupvar)
summary_emm <- summary(emm, level = 0.95)
contrasts <- summary(contrast(emm, method = "pairwise"), infer = TRUE)
aovm <- tryCatch(anova(model), error = function(e) NULL)
eta2 <- tryCatch({
ss_group <- aovm[groupvar, "Sum Sq"]
ss_total <- sum(aovm[,"Sum Sq"])
ss_group/ss_total
}, error = function(e) NA)
adj_r2 <- tryCatch(summary(model)$adj.r.squared, error = function(e) NA)
g1 <- levels(df[[group_var]])[1]
g2 <- levels(df[[group_var]])[2]
n1 <- get_sample_size(df, v, g1)
n2 <- get_sample_size(df, v, g2)
miss1 <- get_missing_pct_tbl(df, v, g1)
miss2 <- get_missing_pct_tbl(df, v, g2)
tibble(
Variable = v,
Unit = if (!is.null(units) && !is.na(units[v])) units[v] else "",
N_StableCN = n1,
N_CNtransitMCI = n2,
StableCN_AdjMean_CI = sprintf("%.2f (%.2f, %.2f)", summary_emm$emmean[summary_emm[[groupvar]] == g1],
summary_emm$lower.CL[summary_emm[[groupvar]] == g1],
summary_emm$upper.CL[summary_emm[[groupvar]] == g1]),
CNtransitMCI_AdjMean_CI = sprintf("%.2f (%.2f, %.2f)", summary_emm$emmean[summary_emm[[groupvar]] == g2],
summary_emm$lower.CL[summary_emm[[groupvar]] == g2],
summary_emm$upper.CL[summary_emm[[groupvar]] == g2]),
Diff_CI = sprintf("%.2f (%.2f, %.2f)", contrasts$estimate[1], contrasts$lower.CL[1], contrasts$upper.CL[1]),
SE = round(contrasts$SE[1],2),
PValue = round(contrasts$p.value[1],4),
EtaSq = round(eta2,3),
Adj_R2 = round(adj_r2,3),
Miss_StableCN = round(miss1,2),
Miss_CNtransitMCI = round(miss2,2)
)
}) %>% bind_rows()
}
tbl2_journal <- get_ancova_table(vars_table2, group_var, covars, df_baseline, units_table2)
write.csv(tbl2_journal, file.path(output_dir, "table2_journalformat_full.csv"), row.names = FALSE)
cat("Table 2 exported as .csv file in", output_dir, "\n")
# ---- Table 3: Segmental Variables (Adjusted) ----
vars_table3 <- c('ECW_TBW_upper','ECW_TBW_lower',
'R_upper','R_lower','Xc_upper','Xc_lower','PA_upper','PA_lower')
units_table3 <- c(
ECW_TBW_upper = "%", ECW_TBW_lower = "%",
R_upper = "Ohm", R_lower = "Ohm", Xc_upper = "Ohm", Xc_lower = "Ohm",
PA_upper = "degree", PA_lower = "degree"
)
tbl3_journal <- get_ancova_table(vars_table3, group_var, covars, df_baseline, units_table3)
write.csv(tbl3_journal, file.path(output_dir, "table3_journalformat_full.csv"), row.names = FALSE)
cat("Table 3 exported as .csv file in", output_dir, "\n")
bia_vars <- c("SNSB_attention","SNSB_language", "SNSB_visuospatial", "SNSB_memory", "SNSB_frontal","bmi","whr","pbcm","pbf","bmr","icw", "ecw", "tbw", "protein", "amc",
"R_upper","R_lower","Xc_upper","Xc_lower",
"PA_upper","PA_lower", "SW_upper", "SW_lower", "SL_upper", "SL_lower","SL_tr", "SL_tr",
"R5_upper", "R5_lower",
"Xc5_upper", "Xc5_lower", "z1_upper", "z1_lower", "z5_upper", "z5_lower")
df_long.analysis <- df4 %>%
filter(Change_Type %in% c("StableCN", "CNtransitMCI"))
spaghetti_plots <- lapply(bia_vars, function(var) {
ggplot(df_long.analysis, aes(x = elapsed_years, y = .data[[var]], group = USUBJID, color = Change_Type)) +
geom_line(alpha = 0.35) +
geom_smooth(aes(group = Change_Type, color = Change_Type), method = "loess", se = FALSE, linewidth = 1.5) +
labs(title = paste("Spaghetti Plot:", var), y = var, x = "Years") +
theme_minimal()
})
do.call(cowplot::plot_grid, c(spaghetti_plots[1:6], ncol = 2))
do.call(cowplot::plot_grid, c(spaghetti_plots[1:9], ncol = 3))
print(spaghetti_plots[[1]])
#for(i in seq_along(bia_vars)) {
#  ggsave(filename = paste0("spaghetti_", bia_vars[i], ".png"),
#         plot = spaghetti_plots[[i]], width = 6, height = 4)
#}
# --- Libraries ---
library(lmerTest)
library(ggeffects)
# --- Utility function for reliable rounding ---
safe_num <- function(x) {
if (is.numeric(x) && length(x) == 1 && !is.na(x) && is.finite(x)) round(x, 4) else NA_real_
}
colors.legend <- c("StableCN" = "#1f77b4", "CNtransitMCI" = "#ff7f0e")
# --- Data Preparation ---
df_long.analysis$Change_Type <- as.character(df_long.analysis$Change_Type)
df_long.analysis <- df_long.analysis[df_long.analysis$Change_Type %in% c("StableCN", "CNtransitMCI"), ]
df_long.analysis$Change_Type <- factor(df_long.analysis$Change_Type, levels = c("StableCN", "CNtransitMCI"))
referencegroup <- "StableCN"
comparisongroups <- c("CNtransitMCI")
# --- Main Function (defensive extraction) ---
analyze_longitudinal_trends_LRT <- function(
data, response, xvar = "elapsed_years", groupvar = "Change_Type",
covariates = c("AGE", "SEX", "EDUYR"), subjectid = "USUBJID",
referencegroup, comparisongroups,
verbose = TRUE
) {
data <- data[data[[groupvar]] %in% c(referencegroup, comparisongroups), ]
data[[groupvar]] <- factor(as.character(data[[groupvar]]), levels = c(referencegroup, comparisongroups))
if (!response %in% names(data) || all(is.na(data[[response]]))) {
warning(paste("Skipping:", response))
return(list(modelsummary = tibble(
Outcome = response, Comparison = paste(comparisongroups, "vs", referencegroup),
Slope_Ref = NA, Slope_Comp = NA, Slope_Diff = NA, Slope_SE = NA, Slope_Lower = NA,
Slope_Upper = NA, Slope_p = NA, Cohen_d = NA, Wald_p = NA, LRT_p = NA,
LRT_chi = NA, LRT_df = NA, ResidualSD = NA)))
}
formula_full <- as.formula(
paste0(response, " ~ ", xvar, "*", groupvar, " + ", paste(covariates, collapse=" + "),
" + (1 + ", xvar, "|", subjectid, ")"))
formula_noint <- as.formula(
paste0(response, " ~ ", xvar, " + ", groupvar, " + ", paste(covariates, collapse=" + "),
" + (1 + ", xvar, "|", subjectid, ")"))
mod_full <- tryCatch(lmerTest::lmer(formula_full, data = data, REML=FALSE), error = function(e) NA)
mod_noint <- tryCatch(lmerTest::lmer(formula_noint, data = data, REML=FALSE), error = function(e) NA)
if (any(is.na(c(mod_full, mod_noint)))) {
warning(paste("Model fit failed:", response))
return(list(modelsummary = tibble(
Outcome = response, Comparison = paste(comparisongroups, "vs", referencegroup),
Slope_Ref = NA, Slope_Comp = NA, Slope_Diff = NA, Slope_SE = NA, Slope_Lower = NA,
Slope_Upper = NA, Slope_p = NA, Cohen_d = NA, Wald_p = NA, LRT_p = NA,
LRT_chi = NA, LRT_df = NA, ResidualSD = NA)))
}
lrt <- anova(mod_noint, mod_full)
lrt_p <- lrt$`Pr(>Chisq)`[2]
lrt_chi <- lrt$Chisq[2]
lrt_df <- lrt$Df[2]
coefmat <- coef(summary(mod_full))
interaction_row <- grep(paste0(xvar, ":", groupvar), rownames(coefmat), value = TRUE)
wald_p <- if(length(interaction_row) > 0) coefmat[interaction_row, "Pr(>|t|)"] else NA_real_
sigma_resid <- suppressWarnings(sigma(mod_full))
# --- FIXED SLOPE EXTRACTION ---
Slope_Ref <- Slope_Comp <- Cohen_d <- NA_real_
emt <- tryCatch(emmeans::emtrends(mod_full, specs = groupvar, var = xvar), error = function(e) NULL)
sum_emt <- if (!is.null(emt)) tryCatch(summary(emt, infer=TRUE), error = function(e) NULL) else NULL
if (!is.null(sum_emt)) {
trend_col <- grep("\\.trend$", colnames(sum_emt), value = TRUE)
group_vals <- as.character(sum_emt[[groupvar]])
ref_idx <- which(group_vals == referencegroup)
comp_idx <- which(group_vals == comparisongroups[1])
ref_good <- (length(ref_idx) == 1) && !is.na(ref_idx)
comp_good <- (length(comp_idx) == 1) && !is.na(comp_idx)
if (ref_good && comp_good && length(trend_col) == 1) {
ref_est <- sum_emt[[trend_col]][ref_idx]
comp_est <- sum_emt[[trend_col]][comp_idx]
if (is.numeric(ref_est) && is.numeric(comp_est) &&
length(ref_est) == 1 && length(comp_est) == 1 &&
is.finite(ref_est) && is.finite(comp_est) &&
is.numeric(sigma_resid) && length(sigma_resid) == 1 &&
is.finite(sigma_resid) && sigma_resid != 0) {
Slope_Ref <- safe_num(ref_est)
Slope_Comp <- safe_num(comp_est)
Cohen_d <- safe_num(abs((Slope_Comp - Slope_Ref) / sigma_resid))
}
}
if ((is.na(Slope_Ref) || is.na(Slope_Comp)) && verbose) {
cat("\n--SLOPE MATCH ERROR--\ntrend_col found:", trend_col, "\ngroupvar:", groupvar,
"ref_idx:", ref_idx, "comp_idx:", comp_idx, "\nsum_emt:\n")
print(sum_emt)
}
}
# Contrast and CIs
contrast_out <- if (!is.null(emt)) tryCatch(emmeans::contrast(emt, method = "revpairwise"), error = function(e) NULL) else NULL
sum_contrast <- if (!is.null(contrast_out)) tryCatch(summary(contrast_out, infer=TRUE), error = function(e) NULL) else NULL
contrastA <- paste(referencegroup, comparisongroups[1], sep = " - ")
contrastB <- paste(comparisongroups[1], referencegroup, sep = " - ")
Slope_Diff <- Slope_SE <- Slope_Lower <- Slope_Upper <- Slope_p <- NA_real_
if (!is.null(sum_contrast)) {
idx <- which(sum_contrast$contrast %in% c(contrastA, contrastB))
sign_mult <- if(length(idx) == 1 && sum_contrast$contrast[idx] == contrastA) 1 else -1
if (length(idx) == 1) {
Slope_Diff  <- safe_num(sign_mult * sum_contrast$estimate[idx])
Slope_SE    <- safe_num(sum_contrast$SE[idx])
Slope_Lower <- safe_num(sign_mult * sum_contrast$lower.CL[idx])
Slope_Upper <- safe_num(sign_mult * sum_contrast$upper.CL[idx])
Slope_p     <- if(is.numeric(sum_contrast$p.value[idx])) round(sum_contrast$p.value[idx], 5) else NA_real_
}
}
modelsummary <- tibble(
Outcome = response,
Comparison = paste(comparisongroups, "vs", referencegroup),
Slope_Ref, Slope_Comp, Slope_Diff, Slope_SE, Slope_Lower,
Slope_Upper, Slope_p, Cohen_d, Wald_p = wald_p, LRT_p = lrt_p,
LRT_chi = lrt_chi, LRT_df = lrt_df, ResidualSD = round(sigma_resid, 3)
)
list(modelsummary = modelsummary, mod_full = mod_full, mod_noint = mod_noint,
lrt = lrt, wald_p = wald_p, slopes = sum_emt, contrast = sum_contrast, cohensd = Cohen_d)
}
biavars <- c(
"SNSB_attention", "SNSB_language", "SNSB_visuospatial", "SNSB_memory", "SNSB_frontal",
"bmi", "whr", "pbcm", "pbf", "bmr", "icw", "ecw", "tbw", "protein", "smm", "amc",
"R_upper", "R_lower", "Xc_upper", "Xc_lower", "PA_upper", "PA_lower",
"SW_upper", "SW_lower", "SL_upper", "SL_lower","SW_tr", "SL_tr",
"R5_upper", "R5_lower",
"Xc5_upper", "Xc5_lower", "z1_upper", "z1_lower", "z5_upper", "z5_lower"
)
results <- lapply(biavars, function(var) {
cat("Analyzing:", var, "\n")
analyze_longitudinal_trends_LRT(
data = df_long.analysis,
response = var,
groupvar = "Change_Type",
referencegroup = referencegroup,
comparisongroups = comparisongroups
)
})
modelsummarylist <- lapply(results, function(x) x$modelsummary)
allsummaries <- bind_rows(modelsummarylist, .id = "Biomarker")
write.csv(allsummaries, "Bioimpedance_LME_LRT_summary.csv", row.names = FALSE)
cat("Summary table complete!\n")
# --- Plotting Functions ---
plot_lmer_model_with_interaction_p <- function(
data, response, xvar = "elapsed_years", groupvar = "Change_Type",
covariates = c("AGE", "SEX", "EDUYR"), colors = colors.legend, subjectid = "USUBJID", show.legend = TRUE
) {
ffixed <- paste0(response, " ~ ", xvar, "*", groupvar, " + ", paste(covariates, collapse=" + "), " + (1 + ", xvar, "|", subjectid, ")")
formula_full <- as.formula(ffixed)
mod <- lmerTest::lmer(formula_full, data = data)
pred <- ggeffects::ggpredict(mod, terms = c(xvar, groupvar)) %>% as.data.frame()
coefmat <- coef(summary(mod))
cname <- grep(paste0(xvar, ":", groupvar), rownames(coefmat), value=TRUE)
raw_pval <- if(length(cname)==1) coefmat[cname, "Pr(>|t|)"] else NA
signif_star <- if (!is.na(raw_pval)) { if (raw_pval < 0.001) "***" else if (raw_pval < 0.01) "**" else if (raw_pval < 0.05) "*" else "" } else ""
subtitle_wald <- if(!is.na(raw_pval)) paste0("Wald interaction p = ", formatC(raw_pval, digits=3), " ", signif_star) else "Wald interaction p = NA"
ggplot(data, aes_string(x = xvar, y = response, color = groupvar, group = paste0("interaction(", groupvar, ",", subjectid, ")"))) +
geom_line(alpha = 0.25, linewidth = 0.7) +
geom_line(data = pred, aes(x = x, y = predicted, color = group), linewidth = 1.7, inherit.aes=FALSE) +
scale_color_manual(values = colors) +
labs(title = paste(response, "trajectory by group"), subtitle = subtitle_wald,
color = "Group", x = xvar, y = response) +
theme_minimal(base_size = 14) +
theme(legend.position = if(show.legend) "top" else "none", legend.title = element_text(size = 13), legend.text = element_text(size = 12), plot.title = element_text(hjust = 0.5))
}
plot_lmer_interaction_with_p <- function(
data, response, xvar = "elapsed_years", groupvar = "Change_Type",
covariates = c("AGE", "SEX", "EDUYR"), colors = colors.legend, subjectid = "USUBJID", show.legend = TRUE
) {
ffixed <- paste0(response, " ~ ", xvar, "*", groupvar, " + ", paste(covariates, collapse=" + "), " + (1 + ", xvar, "|", subjectid, ")")
fnoint <- paste0(response, " ~ ", xvar, " + ", groupvar, " + ", paste(covariates, collapse=" + "), " + (1 + ", xvar, "|", subjectid, ")")
formula_full <- as.formula(ffixed)
formula_noint <- as.formula(fnoint)
mod_full <- lmerTest::lmer(formula_full, data = data, REML=FALSE)
mod_noint <- lmerTest::lmer(formula_noint, data = data, REML=FALSE)
lrt <- anova(mod_noint, mod_full); omnibus_p <- lrt$`Pr(>Chisq)`[2]; chisq_val <- lrt$Chisq[2]; df_val <- lrt$Df[2]
sigstars <- function(p) if (p < 0.001) "***" else if (p < 0.01) "**" else if (p < 0.05) "*" else ""
subtitle_lrt <- sprintf("LRT: Interaction χ² = %.2f, df = %d, p = %.3g %s", chisq_val, df_val, omnibus_p, sigstars(omnibus_p))
pred <- ggeffects::ggpredict(mod_full, terms = c(xvar, groupvar)) %>% as.data.frame()
ggplot(data, aes_string(x = xvar, y = response, color = groupvar, group = paste0("interaction(", groupvar, ",", subjectid, ")"))) +
geom_line(alpha = 0.25, linewidth = 0.7) +
geom_line(data = pred, aes(x = x, y = predicted, color = group), linewidth = 1.7, inherit.aes=FALSE) +
scale_color_manual(values = colors) +
labs(title = paste(response, "trajectory by group"), subtitle = subtitle_lrt,
color = "Group", x = xvar, y = response) +
theme_minimal(base_size = 14) +
theme(legend.position = if(show.legend) "top" else "none", legend.title = element_text(size = 13), legend.text = element_text(size = 12), plot.title = element_text(hjust = 0.5))
}
# --- Batch Plotting & Save ---
output_dir_wald <- "Bioimpedance_Trajectory_WaldPlots"
output_dir_lrt <- "Bioimpedance_Trajectory_LRTPlots"
dir.create(output_dir_wald, showWarnings = FALSE)
dir.create(output_dir_lrt, showWarnings = FALSE)
plots_wald <- lapply(biavars, function(var) plot_lmer_model_with_interaction_p(data = df_long.analysis, response = var, colors = colors.legend, show.legend = TRUE))
plots_lrt  <- lapply(biavars, function(var) plot_lmer_interaction_with_p(data = df_long.analysis, response = var, colors = colors.legend, show.legend = TRUE))
for (i in seq_along(biavars)) {
pw <- plots_wald[[i]]; pl <- plots_lrt[[i]]
if (inherits(pw, "ggplot")) {
ggsave(filename = file.path(output_dir_wald, paste0(biavars[i], "_waldplot.png")), plot = pw, width = 7, height = 5, dpi = 300)
}
if (inherits(pl, "ggplot")) {
ggsave(filename = file.path(output_dir_lrt, paste0(biavars[i], "_lrtplot.png")), plot = pl, width = 7, height = 5, dpi = 300)
}
}
cat("Batch plotting complete!\n")
library(performance)
if (!dir.exists("Diagnostics")) dir.create("Diagnostics")
safe_var_extract <- function(vardf, grpval, var1val, var2val) {
idx <- which(vardf$grp==grpval & vardf$var1==var1val & vardf$var2==var2val)
if(length(idx)==1 && !is.na(vardf$vcov[idx])) vardf$vcov[idx] else NA_real_
}
safe_r2 <- function(model) {
out <- tryCatch(
suppressWarnings(performance::r2(model)),
error = function(e) list(R2_marginal=NA_real_, R2_conditional=NA_real_)
)
list(marginal=out$R2_marginal, conditional=out$R2_conditional)
}
diagnostics_list <- lapply(seq_along(biavars), function(i) {
var <- biavars[i]
m <- results[[i]]$mod_full
png(filename = sprintf("Diagnostics/%s_QQplot.png", var), width = 700, height = 700)
qqnorm(residuals(m)); qqline(residuals(m)); dev.off()
png(filename = sprintf("Diagnostics/%s_ResVsFitted.png", var), width = 700, height = 700)
plot(fitted(m), residuals(m), main = paste(var, "Fitted vs Residuals"),
xlab = "Fitted Values", ylab = "Residuals"); abline(h = 0, lty = 2); dev.off()
aic <- tryCatch(AIC(m), error=function(e) NA_real_)
bic <- tryCatch(BIC(m), error=function(e) NA_real_)
r2 <- safe_r2(m)
ranef_var <- tryCatch(as.data.frame(VarCorr(m)), error=function(e) data.frame())
rand_intercept <- if(nrow(ranef_var)>0) safe_var_extract(ranef_var,"USUBJID","","") else NA_real_
rand_slope <- if(nrow(ranef_var)>0) safe_var_extract(ranef_var,"USUBJID","elapsed_years","") else NA_real_
conv_warn <- if (!is.null(m@optinfo$conv$lme4$messages)) paste(m@optinfo$conv$lme4$messages, collapse="; ") else NA
singular_flag <- if (isSingular(m, tol=1e-4)) "singular" else NA
data.frame(Biomarker = var,
AIC = aic, BIC = bic,
Marginal_R2 = r2$marginal,
Conditional_R2 = r2$conditional,
RandomInterceptVar = rand_intercept,
RandomSlopeVar = rand_slope,
ConvergenceWarning = conv_warn,
SingularFit = singular_flag)
})
diagnostics_df <- do.call(rbind, diagnostics_list)
write.csv(diagnostics_df, "Diagnostics/Bioimpedance_LME_diagnostics.csv", row.names = FALSE)
